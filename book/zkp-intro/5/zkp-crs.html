<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>（五）埋藏「秘密」 - World of Z2O-K7E</title>


        <!-- Custom HTML head -->
        <meta property="og:title" content="zkp-intro/5/zkp-crs.md" />
        <meta name="description" content="零知世界, Halo2 Tutorial, world of Zero-knowledge proof, Halo2 教程">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././mdbook-admonish.css">
        <link rel="stylesheet" href="../../theme/css/mdbook-admonish.css">
        <link rel="stylesheet" href="../../theme/css/open-in.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../index.html">🌟 About z2o-k7e  /zu:ˈki:/</a></li><li class="chapter-item affix "><a href="../../vision.html">🚩 Our Vision & Roadmap</a></li><li class="chapter-item affix "><a href="../../how-to-contribute.html">📖 How-to-contribute</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><a href="../../beginner.html">ZKP 新手村入门攻略</a></li><li class="chapter-item affix "><a href="../../zk-everything/zk-everything-Jade/Hello_ZKP.html">Hello ZKP</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item expanded "><a href="../../zkp-intro/toc.html">探索零知识证明系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zkp-intro/1/zkp-back.html">（一）初识「零知识」与「证明」</a></li><li class="chapter-item "><a href="../../zkp-intro/2/zkp-simu.html">（二）理解「模拟」</a></li><li class="chapter-item "><a href="../../zkp-intro/3/zkp-pok.html">（三）寻找「知识」</a></li><li class="chapter-item "><a href="../../zkp-intro/4/zkp-rom.html">（四）随机「挑战」</a></li><li class="chapter-item expanded "><a href="../../zkp-intro/5/zkp-crs.html" class="active">（五）埋藏「秘密」</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../zk-snarks/toc.html">从零开始学习 zk-SNARK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zk-snarks/1-Polynomial-Interaction-and-Proof.html">1-Polynomial-Interaction-and-Proof</a></li><li class="chapter-item "><a href="../../zk-snarks/2-Non-interactivity&Distributed-Setup.html">2-Non-interactivity&Distributed-Setup</a></li><li class="chapter-item "><a href="../../zk-snarks/3-General-Purpose-Computation.html">3-General-Purpose-Computation</a></li><li class="chapter-item "><a href="../../zk-snarks/4-Construction-Properties.html">4-Construction-Properties.md</a></li><li class="chapter-item "><a href="../../zk-snarks/5-Pinocchio-Protocol.html">5-Pinocchio-Protocol</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-intro.html">理解 Plonk 系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-arithmetization.html">1-Plonkish Arithmetization</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-lagrange-basis.html">2-多项式编码</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-permutation.html">3-置换证明</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-constraints.html">4-算术约束与拷贝约束</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-polycom.html">5-多项式承诺</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-randomizing.html">6-实现 Zero Knowledge</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-lookup.html">7-Lookup Gate</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../lasso-zh/lasso-intro.html">理解 Lasso 系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lasso-zh/lasso-0.html">理解 Lasso（零）：带索引的查询证明</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-1.html">理解 Lasso（一）：Offline Memory Checking</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-2.html">理解 Lasso (二)：稀疏向量与 Tensor 结构</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-3.html">理解 Lasso (三)：大表格的稀疏查询证明</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-4.html">理解 Lasso (四)：更多的可分解表格</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-5.html">理解 Lasso (五)：表格的 MLE 结构</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../halo2/halo2.html">Halo2 Tutorial</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../halo2/chap-0/index.html">1-basic concepts</a></li><li class="chapter-item "><a href="../../halo2/chap-1/index.html">2-simple-circuit</a></li><li class="chapter-item "><a href="../../halo2/chap-2/index.html">3-custom-gate</a></li><li class="chapter-item "><a href="../../halo2/chap-3/index.html">4-fibonacci</a></li><li class="chapter-item "><a href="../../halo2/chap-4/index.html">5-range-check</a></li><li class="chapter-item "><a href="../../halo2/cost-model.html">6-cost-model</a></li><li class="chapter-item "><a href="../../halo2/halo2-QA.html">halo2-QA</a></li><li class="chapter-item "><a href="../../halo2/tmp/halo2-learning-materials.html">halo2-learning-materials</a></li><li class="chapter-item "><a href="../../halo2/tmp/halo2-learning-materials.html">learning-halo2 (0xPARC)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../halo2/tmp/1-Simple-Example.html">1-Simple Examples</a></li><li class="chapter-item "><a href="../../halo2/tmp/2-Fibonacci-example-1.html">2-Fibonacci-example-1</a></li><li class="chapter-item "><a href="../../halo2/tmp/3-Fibonacci-example-2.html">3-Fibonacci-example-2</a></li><li class="chapter-item "><a href="../../halo2/tmp/4-IsZero-Check-example-3.html">4-IsZero Check-example-3</a></li><li class="chapter-item "><a href="../../halo2/tmp/5-Range-check.html">5-Range check-example-1.md</a></li><li class="chapter-item "><a href="../../halo2/tmp/6-Range-Check(code-explanation).html">6-Range Check (code explanation)</a></li><li class="chapter-item "><a href="../../halo2/tmp/7-Range-Check-lookup(example-2).html">7-Range Check-Lookup-example-2)</a></li><li class="chapter-item "><a href="../../halo2/tmp/8-Range-Check(example-3).html">8-Range Check-Lookup-example-3)</a></li><li class="chapter-item "><a href="../../halo2/tmp/9-decomposed.html">9-Range Check-Decompose)</a></li><li class="chapter-item "><a href="../../halo2/tmp/ZKP-APP.html">ZKP Apps with halo2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../halo2/tmp/Zordle.html">Zordle</a></li><li class="chapter-item "><a href="../../halo2/tmp/Hammster.html">Hammster</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-1-Basic.html">Lattice-based Crypography</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-1-Basic.html">Lattice-1-Basic</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-2-LLL.html">Lattice-2-LLL</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-3-CVP.html">Lattice-3-CVP</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-4-RSA.html">Lattice-4-RSA</a></li></ol></li><li class="chapter-item "><a href="../../zkp-QA.html">Recurrent Q&A</a></li><li class="chapter-item "><a href="../../zk-everything/toc.html">zk-everything</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zk-everything/BabySNARK tutorial.html">BabySNARK tutorial</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/KZG.html">KZG</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture1:Overview about Zeroknowledge.html">Lecture1:Overview about Zeroknowledge</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture2:Introduction to Modern SNARKs.html">Lecture2:Introduction to Modern SNARKs</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture12:ZKEVM.html">Lecture12:ZKEVM</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture16:Hardware acceleration.html">Lecture16:Hardware acceleration</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/GKR_with_ZK_Argument.html">Spartan preliminary: GKR with ZK Argument</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/Hyrax.html">Spartan preliminary: Hyrax</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/Spartan.html">Spartan In Depth</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/Theory_and_Practical_Implementation_of_BLS12-381.html">BLS12-381 理论与实现</a></li><li class="chapter-item "><a href="../../Nova/SuperNova.html">SuperNova</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../public goods/toc.html">ZKP Public Goods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../public goods/第二章.html">ch2</a></li><li class="chapter-item "><a href="../../public goods/4-Proving-System.html">ch4-Proving System</a></li><li class="chapter-item "><a href="../../public goods/5-plonk-intro.html">ch5-plonk-intro</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../materials/ZK-Materials.html">ZK Materials</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item "><a href="../../exp/toc.html">经验心得</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../exp/guoyu.html">郭宇：ZK 技术的学习心得和经验分享</a></li><li class="chapter-item "><a href="../../exp/freeyao.html">对话姚翔：解读零知识证明的前世今生</a></li><li class="chapter-item "><a href="../../https://zhuanlan.zhihu.com/p/268305208.html">邓燚：零知识，模拟与归约（一个个人化的视角）</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../zkp-space/toc.html">ZKP Space</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zkp-space/2023-10-22-zkp-coprocessor.html">2023.10.12: 聊聊 ZKP Coprocessor</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">World of Z2O-K7E</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change Language" aria-label="Change Language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme"><a id="lang-cn">中文</a></button></li>
                            <li role="none"><button role="menuitem" class="theme"><a id="lang-en">English</a></button></li>
                        </ul>
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/zkp-co-learning/zkp-co-learning.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/zkp-co-learning/zkp-co-learning.github.io/edit/main/src/zkp-intro/5/zkp-crs.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="埋藏秘密"><a class="header" href="#埋藏秘密">埋藏「秘密」</a></h1>
<ul>
<li><a href="#crs-%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F">CRS 的前世今生</a></li>
<li><a href="#%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98">哈密尔顿环路问题</a>
<ul>
<li><a href="#zk-ham-%E5%8D%8F%E8%AE%AE">ZK-HAM 协议</a></li>
<li><a href="#zk-ham-%E7%9A%84%E5%8F%98%E5%BD%A2zk-ham-2">ZK-HAM 的变形：ZK-HAM-2</a></li>
</ul>
</li>
<li><a href="#%E4%BA%91%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86hidden-bits">云中的秘密：Hidden Bits</a></li>
<li><a href="#%E5%8D%87%E7%BA%A7%E9%9A%8F%E6%9C%BA%E6%80%A7">升级随机性</a></li>
<li><a href="#fls-%E5%8F%98%E6%8D%A2%E4%BB%8E-hidden-bits-%E5%88%B0-nizk">FLS 变换：从 Hidden Bits 到 NIZK</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E7%90%86%E6%83%B3%E7%9A%84-trapdoor-permutation">寻找理想的 Trapdoor Permutation</a></li>
<li><a href="#nizk-proofs--%E4%B8%8E-nizk-arguments">NIZK Proofs  与 NIZK Arguments</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E7%A7%98%E5%AF%86%E7%9A%84%E4%B8%96%E7%95%8C">没有秘密的世界</a></li>
<li><a href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD">未完待续</a>
<ul>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>Once exposed, a secret loses all its power.  一旦泄露，秘密就失去了全部威力  ― <strong>Ann Aguirre</strong></p>
</blockquote>
<p>这已经是本系列的第五篇文章了，这一篇继续深入非交互式零知识证明。 本文约 12,000 字。</p>
<p><strong>提纲</strong></p>
<ol>
<li>CRS 的前世今生</li>
<li>哈密尔顿环路问题</li>
<li>云中的秘密：Hidden Bits</li>
<li>升级随机性</li>
<li>FLS变换：从 Hidden Bits 到 NIZK</li>
<li>寻找理想的 Trapdoor Permutation</li>
<li>NIZK Proof vs. NIZK Argument</li>
<li>没有秘密的世界</li>
</ol>
<p>追到这里的读者想必已对零知识证明有了一个大概的认识。你是否想过这个问题：零知识证明为何可行？这里请大家思考一下（比如<a href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/1/zkp-back.md">系列一</a> 中的地图三染色问题的流程） …… （此处停留三分钟）下面两个要素 <strong>似乎</strong> 必不可少：</p>
<ol>
<li>「交互」：验证者通过多次反复挑战，把证明者作弊概率降低到一个极小的值</li>
<li>「隐藏随机性」：验证者产生让证明者无法预测的随机数进行挑战</li>
</ol>
<p>然而对于非交互式零知识证明—— NIZK 来说，如何实现上面两点？在 <a href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/4/zkp-rom.md">系列四</a> 我们介绍了如何采用「随机预言机」来扮演一个虚拟的「第三方」角色，实现虚拟的「交互」与「随机挑战」。本文将深入讲述另一种方法，如何通过一段共享的字符串去除「交互」与「隐藏随机性」。这个字符串必须事先由「第三方」来随机产生，这就是传说中的「公共参考串」（Common Reference String，简称 CRS）。</p>
<h2 id="crs-的前世今生"><a class="header" href="#crs-的前世今生">CRS 的前世今生</a></h2>
<p>假如我们不借助任何其它手段，限定证明者 Prover 和验证者 Verifier 只能进行「一次交互」来实现「零知识证明」，那么他们只能证明「平凡」问题，也就是计算复杂类 <code>BPP</code>（<strong>Bounded-error Probabilistic Polynomial time</strong>），而这个复杂度类大家一般猜想可能等价于 <code>P</code>（但还悬而未决，没有被证明！<code>BPP</code> 可以理解为 <code>P</code> + <code>Randomness</code>）。</p>
<p><em>注：如果 Prover 与 Verifier 只做一次交互，在这样的 NIZK 系统中，我们很容易能构造一个 Decision Procedure —— Verify(x, Sim(x))，来证明和证伪定理，因此只能证明平凡问题 BPP。</em></p>
<p>平凡问题虽然也可以零知识证明，但没有意义！怎么理解呢？因为验证者直接可以在多项式时间内根据「输出」求解出「秘密输入」，虽然验证者能够求解，但是「证明」本身并没有额外为验证者提供更多的「知识」。换句话说，不需要证明者出示证明，验证者就知道命题为真，于是证明过程也是零知识的。</p>
<p>因此，当我们讨论「零知识证明」时，要考虑带「知识」的 <code>NP</code> 类问题。大家都知道，<code>P</code> 问题是「确定性图灵机」多项式时间内可以求解的复杂类，它的执行路径对于输入 <code>x</code>是一个线性的状态转移。而 <code>NP</code> 问题是「不确定性图灵机」多项式时间可以求解的问题类。所谓的不确定性图灵机，就是它每次往前走一步是不确定的，有很多个选择，只要任何一个执行路径能到达终止状态，就表示它解决了该问题 <code>x</code>。换句话说，它的执行轨迹是一棵树。那么如果我们把不确定性图灵机每一步的路径选择记录下来（这个执行路径的记录叫做 <code>witness</code>，也就是我们反复提到的「知识」），那么把<code>(x, witness)</code>交给一个确定性图灵机，那么它也能在多项式时间内解决掉 <code>x</code> 问题。</p>
<p>再强调一下，「知识」能提高图灵机的解决问题的能力。</p>
<p><code>NP</code> 问题中存在着不想「泄露」给验证者的知识 <code>witness</code>，这时，在一个交互式证明系统中，证明者和验证者在「知识」的掌握程度上是不对等的。</p>
<p>为了保证证明过程的「零知识」，我们需要保证：<strong>模拟器与验证者的不对等</strong>。可是，模拟器没有 <code>witness</code>啊，怎么能让他们不对等呢？上一篇我们介绍了「随机预言机」，我们通过允许让模拟器可以绑架「随机预言精灵」的方式制造不平等。本篇将讲述如何利用 CRS 来制造不平等。</p>
<p>CRS 是一个在证明之前就已经公开的，并且在证明者与验证者之间共享的，随机字符串。我们怎么来使用 CRS 呢？直觉上，一串双方都「知道」的信息，并不会增加「知识」不对等的情况。</p>
<p>首先大家会想，能不能直接用 CRS 作为随机挑战数呢？可不可以让 CRS 来代替「随机预言精灵」的角色？答案是不行！</p>
<p>为什么？这是因为 CRS 是在证明之前就已经产生了，如果证明者 Prover 提前知道了所有的随机挑战数，那么很显然这个随机挑战也就失去了意义。</p>
<p><em>注：请大家回想下「随机预言机」是如何保证证明者无法提前预测「随机挑战数」的？没想明白的你，请重读系列（四）。</em></p>
<blockquote>
<p>CRS 的使命就是让「模拟器」与「验证者」不平等。怎么做呢？隐藏一些「秘密」进去。</p>
</blockquote>
<p>如果进一步追问，隐藏了「秘密」有什么用呢？当然有用啦，在「理想世界」中，模拟器与抽取器才能很开心地玩耍起来（获取某些超能力） ……</p>
<p>1988年，Manuel Blum，Paul Feldman 和 Silvio Micali 三位先驱发表的论文	「Non-Interactive Zero-Knowledge and Its Applications」（『非交互式零知识证明及其应用』[BFM88]）展示了「交互」与「隐藏随机性」的不必要性。他们给出了一个地图三染色问题的 NIZK 证明系统，在一段共享的随机产生的字符串（即CRS）的帮助下。</p>
<p>不过，……，我不会告诉你这个方案需要共享大概 <code>n^4</code> 超长的 CRS，其中 <code>n</code>是要证明的「命题」的长度。</p>
<p>1990 年，Uriel Feige，Dror Lapidot 与 Adi Shamir 三人提出了另一种构造 NP 语言的 NIZK 方案 [FLS90]。与 [BFM88] 不一样的是，这个 NIZK 方案不再基于特定的数论假设，而是基于一个密码学工具 Trapdoor Permutation。在这个方案中，FLS 提出了「隐藏比特」（Hidden Bits）的概念，然后把 Hidden Bits 藏入了 CRS。对于模拟器而言，就可以通过修改 CRS 中的 Hidden Bits 来达到模拟的效果，从而体现出对验证者 Verifier 的优越性。不过，这个方案需要共享更长的 CRS，超过 <code>k * n^5</code>，这里 <code>k</code> 是安全参数。</p>
<p>此后，Hidden Bits 的思路被很多人采用，值得一提的是，Kilian 与 Petrank 采用了一种更巧妙的方法来使用 Hidden Bits [KP98]（这里空间太小，写不下:），成功地把 CRS 的长度缩减到了 <code>k * n^2</code>。后来 J. Groth 继续优化 ，把 CRS 的长度缩小到了大约 <code>k*n</code>[Groth10a]。</p>
<p>除了 Hidden Bits，J. Groth，R. Ostrovsky 与 A. Sahai  [GOS06] 使用了同态加密方案 Boneh-Goh-Nissim [BGN05] 或 Boneh-Boyen-Shacham 来实现 NIZK，他们把加密方案的「公钥」当做是 CRS，同时 Prover 加密作为证明，然后利用同态性质来证明另一个 NP-Complete 问题——布尔电路的可满足性问题。这个方案的最大优点，就是 CRS 长度是固定的，因为只是一个密钥而已，长度只有 <code>k</code>。对于模拟器而言，它可以通过超能力，拿到这个公钥所对应的陷门，从而能够实现密封任何信息，但得到相同的密文；对于抽取器而言，它可以用超能力拿到公钥对应的私钥，从而能够解密证明得到「知识」。</p>
<p>Jens Groth 在 2010 年基于 KEA（Knowledge of Exponent Assumption） 假设与 Pairing 提出了一种新的 NIZK Arguments 方案[Gorth10b]，这也是后续许许多多 zkSNARKs 方案的起点。这里的 CRS 由一对对的 （<code>g^x^n, g^⍺x^n</code>） 构成，被用来实现「知识承诺」。其中 <code>x</code> 与 <code>⍺</code> 是两个随机数，在产生完 CRS 之后，必须被「遗忘」。有些人把这部分需要遗忘的随机数叫做「Toxic Wastes」，这容易误导读者。他们不仅无毒无害，而且非常有用。他们是被藏入 CRS 的「秘密」，是模拟器的武器。如果模拟器得到了 <code>x</code> 与 <code>⍺</code>，就能伪造证明，从而保证证明的零知识。而对于抽取器，他能直接通过 KEA 假设内建的抽取函数来抽取知识。</p>
<p>最新的 Sonic 方案[MBK+19]又在 [Groth10b] 的基础上实现了 Updateable CRS。如果任何人担心 CRS 中的秘密已经被泄露了，他就可以在原有 CRS 基础上打一个补丁，继续往里藏一个秘密，这样就能保证 CRS 的安全性。这里的 CRS 还是「Universal 全局」 的，即 CRS 只需要生成一次，就可以应付所有的命题证明。 这个方案后续被最新的 Plonk[GWC19]，Marlin[CHMMVW19] 等方案采用。</p>
<p>接下来，我们就从一个简单的例子开始，理解如何基于 CRS 来构造 NIZK。在这之前，我们需要介绍一个 NP-Complete 问题——哈密尔顿环路问题。</p>
<h2 id="哈密尔顿环路问题"><a class="header" href="#哈密尔顿环路问题">哈密尔顿环路问题</a></h2>
<p>想象出一个地图中有若干个城市，城市与城市间可以有公路。</p>
<p>假如给你一副地图，让你找出一条路径，不重复地走遍所有的公路（假设每条公路都是风景美如明信片的 Parkway，或许你想不重复地吃遍每条公路边上的麦当劳，出于某种情怀）。相信你会马上兴奋起来，这不就是小时候学过的「一笔画」么？判断一个地图能否一笔画，这是小学生做的数学题，我们可以计算每个城市连接的公路个数，根据奇偶性分成「奇点」与「偶点」。如果一个地图中存在两个奇点城市，那么你只能从一个奇点城市出发，遍历所有的公路，并且最终到达另一个奇点城市。这条路径就被称为「欧拉路径」（Euler’s Path）。</p>
<p>如果一个地图中所有的城市都是偶点，那么你可以从任意一个城市出发，轻松地找出一条路径，不重复地遍历所有的公路，并且回到起点。这个环路被称为「欧拉环路」（Euler’s Circuit）。</p>
<p>而如果地图存在超过2个以上的奇点，那么就不存在欧拉回路，比如著名的哥德斯堡七桥问题。</p>
<p>著名的哥德斯堡七桥问题就是这么描述，如果不重复地穿过下面七座桥。</p>
<p><img src="img/konigsberg.jpg" alt="" /></p>
<p>哥德斯堡七桥地图显然存在多个奇点，不存在欧拉路径。如果给定任何一个地图，是否存在一个欧拉环路，这是一个 <code>P</code> 问题，也就是一个计算机可以在 <code>poly(n)</code> 多项式时间内寻找。</p>
<p><em>注：欧拉环路的寻找算法被称为 Fleury算法。</em></p>
<p>对于这样一个 <code>P</code> 问题， 如果一个证明者 Prover 证明他知道一个欧拉回路，那么他可以直接发送回路的明文，然后验证者 Verifier 验证回路正确与否。请注意，这个过程仍然是零知识的。因为，Verifier 并没有通过 Prover 发送的信息获得任何 <strong>额外的知识</strong>。换句话说，Verifier 并没有因为看到回路，而增强了自身计算能力，因为 Verifier 本来就可以自行计算欧拉回路。</p>
<p>而我们要讲的是「哈密尔顿环路问题」则是一个 <code>NP</code> 问题，描述如下：</p>
<p><strong>是否一个地图存在一个环路，能不重复地穿过每一个城市</strong>。</p>
<p>比如下面这张地图：</p>
<p><img src="img/map.png" alt="" /></p>
<p>我们用一个矩阵 <code>V * V </code> 的矩阵来表示这个地图，凡是两个城市<code>（A, B）</code>有公路相连接，那么就在<code>(A, B)</code> 和 <code>(B, A)</code>里面填上 <code>1</code>，否则填 <code>0</code>。这个矩阵被称为「邻接矩阵」，我们可以把这个邻接矩阵拍扁，就变成了一个 <code>0/1</code> 比特串。</p>
<p>寻找「哈密尔顿环路」是一个 <code>NP-Complete</code> 问题，换句话说，不存在一个算法使得计算机在 <code>poly(n)</code> 多项式时间内找到环路。但是，计算机可以在多项式时间内检验一个路径是否是「哈密尔顿环路」。比如这个地图中就有一个带方向的哈密尔顿环路，我们一眼就能验证这个环路确实穿过了每一个城市。如果一个地图有哈密尔顿环路，那么它的矩阵一定是满足下面的特征：每一行一定有一个<code>1</code>，每一列一定也有一个<code>1</code>。</p>
<p><img src="img/ham.png" alt="" /></p>
<h3 id="zk-ham-协议"><a class="header" href="#zk-ham-协议">ZK-HAM 协议</a></h3>
<p>我们下面给出一个三步交互的 <code>Sigma</code> 协议，Alice 向 Bob 证明她「知道」上面这个地图 <code>G</code> 的哈密尔顿环路。</p>
<ul>
<li>公共输入：<code>G</code> 为一个有 6 个顶点的地图，表示为一个 <code>6*6</code> 的邻接矩阵</li>
<li>秘密输入：<code>G</code>的哈密尔顿环路 <code>C</code>（图中橙色的公路）</li>
</ul>
<p><img src="img/3ham1.png" alt="" /></p>
<ul>
<li>第一步：Alice 随机选择一个「置换」，<code>Perm(.)</code>，然后通过这个置换，产生一个新的图 <code>G'</code>；然后 Alice 把<code>G'</code> 矩阵的每一个单元加密，产生一个新的矩阵发送给 Bob。</li>
</ul>
<p>【名词解释】：所谓置换，大家可以想象成用 <strong>鼠标</strong> 随意拖动图中的点，但是点和点之间的连线会跟着点一起被拖动，拖动结束之后形成的图，进行重新编号就得到 <code>G'</code>，比如上图左侧的两个图。经过置换变换的图前后是 <strong>同构</strong> 的。其中下图中，每一个顶点上角括号中的标号为拖动之前该顶点在上图中的编号。形式化一点可以这么定义：<code>Perm()是一个 {1, V} 到 {1, V}的双射函数</code>新图 <code>G'</code>的邻接矩阵，<code>[perm(i), perm(i+1) ]=1</code> 当且仅当<code> [i, i+1]=1</code>，其中 <code>i</code> 是顶点编号，<code>V</code> 是顶点个数 。</p>
<ul>
<li>第二步：Bob 随机选择 <code>b in {0, 1}}</code> 进行挑战。</li>
</ul>
<p><img src="img/3ham2.png" alt="" /></p>
<ul>
<li>第三步情况（1）：Alice 根据 Bob 第二步发送的值：如果 <code>b=0</code>，那么 Alice 发送置换函数 <code>Perm()</code>，并且揭示完整的图 <code>G'</code>。而 Bob 则确认 <code>G'</code>是否是原图 <code>G</code> 经过置换无误。</li>
</ul>
<p><img src="img/3ham3.png" alt="" /></p>
<ul>
<li>第三步情况（2）：如果 Bob 第二步发送的<code>b=1</code>，那么 Alice 只揭示 <code>G'</code>中的哈密尔顿环路 <code>C'</code>即可。而 Bob 需要验证 <code>C'</code>是否是一个哈密尔顿环路</li>
</ul>
<p>回忆一下三步 Sigma 协议，我们再理解下上面看似复杂的动作：</p>
<ul>
<li>第一步：被称为 <code>Commit</code>，证明者 Alice 需要把手里的答案进行同态变换，产生一个新答案，然后把每一条边都锁起来，交给 Bob；</li>
<li>第二步：Bob 进行随机挑战；</li>
<li>第三步：Alice 根据 Bob 的随机挑战，做出两种不同的回应。如果 Bob 挑战 <code>0</code>，那么Alice 打开第一步的承诺，表示自己在第一步没有作弊；如果 Bob 挑战 <code>1</code>，那么 Alice 只解密暴露出哈密尔顿环路的边（公路），其它边则不需解密。Bob 可以轻易地检查地图上露出来的那些边是否构成了一个不重复地经过所有城市的环路。</li>
</ul>
<p>如果这个 Sigma 协议只走一遍的话， Alice 作弊的概率是 50%，如果重复 n 遍，Alice 作弊概率会指数级减小。大家可以试着用「模拟器」和「抽取器」的方法来证明这个协议的「零知识」与「可靠性」。</p>
<h3 id="zk-ham-的变形zk-ham-2"><a class="header" href="#zk-ham-的变形zk-ham-2">ZK-HAM 的变形：ZK-HAM-2</a></h3>
<p>接下来把上面的这个三步协议改动一下。大家先考虑下这样一个简单事实：如果一个仅包含环路的子图 <code>C</code> 是 图 <code>G</code>的子图，<code>C &lt;= G</code>那么说明 <code>G</code> 包含哈密尔顿环路。</p>
<p>这个事实等价于另一个事实：一个哈密尔顿图 <code>G</code> 的补集 <code>!G</code> 是环路子图 <code>C</code> 的补集 <code>!C</code> 的子图。</p>
<p>【名词解释】图的补集：所谓补集就是这样一个新地图，顶点保持不变，旧地图上的边在新地图中不存在，而新地图中的公路在旧地图中不存在，但是两个图重合在一起，就变成了一个完全图（完全图是指任意两个顶点之间都存在一条边）。</p>
<p>用邻接矩阵来理解，就是如果一个图<code>G</code>包含一个环路子图<code>C</code>，那么<code>G</code>矩阵中所有值为 <code>0</code> 的单元集合 必然被 <code>C</code>矩阵中所有值为<code>0</code>的单元集合包含。可以表示为 <code>!G &lt;= !C</code>。</p>
<p>根据第二个事实，我们可以定义如下的 Sigma 协议：</p>
<ul>
<li>公共输入：图<code>G</code> ，表示为 <code>6*6</code> 的邻接矩阵</li>
<li>秘密输入：<code>G</code>的哈密尔顿环路 <code>C</code>（图中橙色的公路）</li>
</ul>
<p><img src="img/3ham4.png" alt="" /></p>
<ul>
<li>
<p>第一步：</p>
<ul>
<li>Alice 随机选择一个「置换」，<code>Perm(.)</code>，并且通过<code>C</code>构造一个哈密尔顿环路子图 <code>C'=Perm(C)</code>；</li>
<li>然后 Alice 加密 <code>C'</code>的每一个单元，把加密后的结果发送给 Bob。</li>
</ul>
</li>
<li>
<p>第二步：Bob 随机选择 <code>b in {0, 1}</code>进行挑战</p>
</li>
</ul>
<p><img src="img/3ham5.png" alt="" /></p>
<ul>
<li>第三步情况（1）：如果 <code>b=0</code>，Alice 揭示完整的 <code>C'</code>，而 Bob 验证这个 <code>C'</code> 是否确实是一个哈密尔顿环路子图。</li>
</ul>
<p><img src="img/3ham6.png" alt="" /></p>
<ul>
<li>第三步情况（2）：如果 <code>b=1</code>，Alice 发送 <code>Perm()</code>，同时按照 <code>G'=Perm(G)</code>中的所有含 <code>0</code> 单元所在的位置，揭示 <code>C'</code>中所对应的单元；Bob 验证 <code>C'</code>所有被揭示单元是否全部为 <code>0</code>。</li>
</ul>
<p>再理解下这三步 Sigma 协议：</p>
<ul>
<li>第一步：证明者 Alice 需要把哈密尔顿子图 <code>C</code> 进行置换变换，产生一个新的哈密尔顿子图 <code>C'</code>，加密后交给 Bob；</li>
<li>第二步：Bob 进行随机挑战，<code>0</code> 或者 <code>1</code>；</li>
<li>第三步：如果 Bob 挑战 <code>0</code>，那么 Alice 打开第一步的承诺，展示一个带有唯一环路的图；如果 Bob 挑战 <code>1</code>，Alice 则按照 <code>G'</code>中的 <code>0</code>单元的位置打开承诺，展示承诺中被打开的位置全部为 <code>0</code>。</li>
</ul>
<p>重点来了，大家仔细看看这个新版的 Sigma 协议的第一步。有没有发现什么情况？</p>
<p><strong>第一步 Alice 发送的内容是与地图<code>G</code>无关的！</strong></p>
<p>同样，第二步 Bob 发送的挑战也是与地图无关的。这样我们可以把第一步发的承诺改成<strong>事先准备好的比特串</strong>，而且我们假设这个比特串由一个可信第三方来产生，这样一来 Bob 就没有必要发送 <code>b=0</code> 这个分支，因为可信的第三方是诚实的，他一定是事先准备好一个正确的环路子图。这样，由于 Bob 只需要发送 <code>1</code>挑战分支，那么这一步也可以去除。</p>
<p>于是，三步协议变成了一步，我们成功去除了交互，有望实现 NIZK 。</p>
<p>我们接下来把 <code>ZK-HAM-2</code> 协议的第一步和第二步推到一个事先准备的字符串中，然后只让 Alice 发送第三步的内容给 Bob。如下图所示：</p>
<p><img src="img/3ham7.png" alt="" /></p>
<p>请注意，这里还不算是一个 NIZK 系统，因为这个共享字符串并不能对 Bob 公开，否则 Bob 就能算出环路 <code>C</code>。接下来，我们要解释一个新概念：「隐藏比特」（Hidden Bits）[FLS90]。Hidden Bits 是这样一串随机比特，它们对于验证者 Bob 隐藏，但是对于证明者 Alice 公开。然后在证明过程中，Alice 可以选择性地揭示一部分比特展示给 Bob 看。这是构造 NIZK 证明系统的一个利器，下面我们需要再继续深入 ……</p>
<h2 id="云中的秘密hidden-bits"><a class="header" href="#云中的秘密hidden-bits">云中的秘密：Hidden Bits</a></h2>
<p>让我们再次开下脑洞，想象天上有朵云，云后面藏着一串随机产生的比特值，不是 <code>0</code> 就是 <code>1</code>，然后 Alice （证明者）带着一个「超级眼镜」，于是能够看到云后面所有的随机比特串，但是 Bob （验证者）却看不到。同时 Alice 手里还有一个「超级手电筒」，她可以打开手电筒用激光穿透云层，让 Bob 也能看见其中某个或某些比特。当然，Bob 能看到的比特的选择权完全在 Alice 手中。</p>
<p>云朵中隐藏的比特串就是所谓的 <strong>Hidden Bits</strong>。</p>
<p><img src="img/hiddenbits.png" alt="" /></p>
<p>接下来我们要通过 Hidden Bits 来完成一个单步交互，完成 <code>ZK-HAM-2</code> 协议的功能。在 <code>ZK-HAM-2</code> 中的第一步，Alice 产生一个随机的置换 <code>Perm()</code>，然后通过 <code>G</code> 中的哈密尔顿环路子图 <code>C</code> 产生一个变换后的环路子图 <code>C'=Perm(C)</code>。这等价于，事先由任何人产生一个随机的哈密尔顿环路子图 <code>C'</code>，然后 Alice 根据 <code>C</code> 和 <code>C'</code> 计算得出一个相应的 <code>Perm()</code>。</p>
<p>假设由某个「第三方」产生了一个随机的环路子图 <code>C'</code>，编码成「邻接矩阵」比特串，放到云朵后面。假设 <code>V</code> 为顶点（城市）的个数，<code>E</code> 为边（公路）的条数。这个邻接矩阵的编码需要一个 <code>V*V</code> 长度的比特串，可以解释成一个 <code>V*V</code> 的矩阵，其中每一行只包含一个 <code>1</code>，每一列也只包含一个 <code>1</code>，矩阵的其它单元都为 <code>0</code>。</p>
<p>接下来 Alice 如何构造证明呢？这其实很简单：</p>
<p><img src="img/3ham8.png" alt="" /></p>
<ol>
<li>
<p>Alice 通过「超级眼镜」得到了一个随机的哈密尔顿环路子图 <code>C'</code>，然后计算得到一个置换 <code>Perm()</code>，使得 <code>Perm(C)=C'</code>。</p>
</li>
<li>
<p>Alice 根据 <code>Perm()</code> 来计算出一个换后的图 <code>G'=Perm(G)</code></p>
</li>
<li>
<p>Alice 产生证明，由两部分组成：（1）置换<code>Perm()</code> （2）<code>G'</code>的邻接矩阵中所有值为 <code>0</code> 的单元坐标所对应的 <code>C'</code>矩阵的值，相当于 Alice 需要用「超级手电筒」给 Bob 揭示的隐藏比特。</p>
</li>
</ol>
<p>那么 Bob 怎么验证这个证明呢？Bob 拿到证明之后，只需要检验两个东西：</p>
<ol>
<li><code>Perm()</code> 是否是一个合法的置换 <code>V -&gt; V</code>，比如不能出现两个顶点映射到同一个顶点的情况。</li>
<li>对于 <code>G</code> 中的每一条「非边」，经过置换之后，Bob 抬头看天上对应的「隐藏比特」，比特值必须为 <code>0</code></li>
</ol>
<p>我们再仔细地深入理解下这个非交互协议。先从「完备性」入手：如果 Alice 没有作弊，那么很显然能够通过 Bob 的验证，这里请大家自行检查。</p>
<p>接下来我们分两步简要证明下「可靠性」：首先，因为 Bob 经过验证得知，所有 <code>G</code> 置换后的非边集合都已被揭示，且全为 <code>0</code>，那么可以得出结论，<code>!G &lt;= !C</code>，即<code>G</code>的非边集合是环路子图 <code>C</code>的非边集合的子集。这等价于，<code>C &lt;= G</code>，也就是说 <code>G</code> 包含一个哈密尔顿环路。这里请注意，这个可靠性概率是 100%。</p>
<p>然后，设想在一个「理想世界」中，Bob 获得了某种超能力（比如拿到 Alice 的「超级眼镜」），不需要 Alice 的超级手电筒，就能看穿云层，得到所有的隐藏比特 <code>C'</code>。然后当 Bob 得到 <code>Perm()</code>之后，就能通过 <code>Perm()</code> 反算出 <code>C</code>，于是 Bob 就相当于变身成了一个「抽取器」（Extractor），在理想世界中，它能把 Alice 要证明的知识给成功抽取出来。</p>
<p>那么怎么证明「零知识」呢？Alice 要具备一个超能力，就是在「理想世界」中，可以偷偷修改云朵中的隐藏比特。接下来就简单了，模拟器 Zlice 可以这么欺骗 Bob：</p>
<ol>
<li>Zlice 把云朵中的隐藏比特全部置为 <code>0</code></li>
<li>Zlice 随机产生一个合法的 <code>Perm()</code></li>
</ol>
<p>大家发现了，关键是，天上隐藏的比特必须是一个可信的字符串，所谓「可信」，就是指它确实应该是一个哈密尔顿环路子图。那么第三方需要可信。</p>
<p>可是，这样一个第三方是不是难以令人满意？Alice 和 Bob 要绝对信任他，不会和对手串谋。如果他和 Alice 串谋，可以把隐藏比特串直接设置为全 <code>0</code>；或者他和 Bob 串谋，直接把这个比特串给 Bob 看。这个协议看起来不错，但是很难实用。我们接下来要对这个简单协议进行升级。</p>
<h2 id="升级随机性"><a class="header" href="#升级随机性">升级随机性</a></h2>
<p>第一个升级是让隐藏比特串变成一个「一致性均匀分布」的随机的隐藏比特串，是一个看起来相当随机的比特串，而不是一个刻意摆放好的哈密尔顿子图。</p>
<p>完全随机意味着比特串中的 <code>0</code> 的个数和 <code>1</code>出现的概率大概接近。那么接下来一个难题是如何让随机比特串中能出现一个随机的哈密尔顿环路子图矩阵。方法非常简单粗暴：产生一个足够长的随机串，然后从头扫描，直到找到一个随机的哈密尔顿环路为止。</p>
<p>可是……这个成功概率是不是非常非常小？我们下面给出一个概率没那么小的一种寻找方法。</p>
<ol>
<li>我们先把比特串按照 <code>5log(V)</code> 的长度进行切分，然后如果每一个分片中的所有比特全为 <code>1</code>，那么我们把这个片段被视为邻接矩阵中的一个值为 <code>1</code> 的单元，否则视为一个值为 <code>0</code> 的单元。这样每一个矩阵单元出现 <code>1</code> 的概率为 <code>1/(V^5)</code>。</li>
<li>我们取连续的 <code>V^6</code> 个片段，构成一个 <code>V^3 * V^3</code> 的大矩阵。如果大矩阵中包含一个 <code>V*V</code>的哈密尔顿环路矩阵，并且其他单元（总共 <code>V^6 - V^2</code>个） 都为 <code>0</code>。那么我们称这个大矩阵为「有用」。</li>
<li>根据概率计算，出现一个「有用」矩阵的概率为 <code>1/[V^(3/2)]</code>。</li>
</ol>
<p><em>注：「有用」矩阵的概率计算过程请参考 Fact 4.10.8, 「Foundations of Cryptography, Vol I」by Oded Goldreich，P304。</em></p>
<p>好了，我们需要升级下上一节的协议。因为现在「隐藏比特串」被拆分成了若干个大矩阵，这些大矩阵有些是「有用」的，有些是没用的。</p>
<p>接下来 Alice 要来构造证明了，她先戴上超级眼镜，扫描云朵中的 Hidden Bits，这要分两种情况，</p>
<ul>
<li>
<p>Case 1：如果 Alice 遇到了一个没用的大矩阵 <code>M</code>，Alice 公开 <code>M</code> 的所有单元。</p>
</li>
<li>
<p>Case 2：如果 Alice 遇到了一个「有用」的大矩阵 <code>M</code>，这意味着 Alice 得到了一个随机的 哈密尔顿环路 <code>C'</code>，然后 Alice 参照上一节的步骤进行证明即可。</p>
</li>
</ul>
<p>那么 Bob 怎么验证这个证明呢？我们还要分情况进行讨论，</p>
<ul>
<li>Case 1：如果 Alice 公开了全部的 <code>M</code>，那么 Bob 就检查这个 <code>M</code> 是否「无用」。如果 <code>M</code> 无用，就认为证明有效；否则拒绝。</li>
<li>Case 2：如果 Alice 发送的是形如（<code>Perm()</code>，<code>X</code>）这样的证明，那么 Bob 按照上一节的验证方法进行验证。</li>
</ul>
<p>对于这个协议，Bob 已经不再担心第三方是否作弊，故意产生一个全零的比特串，但是 Alice 仍然担心一旦第三方和 Bob 串谋，那么知识就彻底泄露了。</p>
<p>不仅如此，现在的协议还有个很强的限制，Alice 不能在看到隐藏比特之后再选择需要证明的 <code>G</code>，否则 Alice 就可以作弊。如果一个证明者选择证明的「命题」与 CRS 无关，那么这个证明者被称为 Non-adaptive Adversary。</p>
<h2 id="fls-变换从-hidden-bits-到-nizk"><a class="header" href="#fls-变换从-hidden-bits-到-nizk">FLS 变换：从 Hidden Bits 到 NIZK</a></h2>
<p>接下来，我们再次升级协议，把「隐藏比特串」中的隐藏特性去除，变成「公共参考串」CRS。这里我们要借助一个密码学工具 —— Trapdoor Permutation，陷门置换。</p>
<p>所谓的陷门置换是指一个置换函数 <code>F(x)</code>，<code>x</code>是一个集合 <code>S</code> 中的元素，然后函数 <code>F(x)</code> 把<code>x</code> 映射到 <code>S</code> 中的另一个元素 <code>y</code>。同时 <code>F(x)</code> 满足单向性，即通过 <code>y</code> 很难反算出 <code>x</code>；但是如果谁拥有陷门 <code>t</code>，就能实现反向计算<code>F^(-1)(t,y)=x</code>。陷门置换还可以匹配一个 Hardcore Predicate，<code>h(x)=0/1</code>，它能根据 <code>S</code> 集合中的元素产生一个一致性分布的 <code>0/1</code>比特。介绍完毕，大家是不是有点晕，没关系，晕一晕就习惯了。总之一句话，陷门置换可以对公共参考串和Hidden Bits 进行相互转换。</p>
<p>先假设有这样的密码学工具，然后我们升级协议。</p>
<p><img src="img/fls.png" alt="" /></p>
<p>我们把公共参考串看成是一个列表，<code>y1, y2, y3, ..., yn</code>，列表中的每一项都是集合 <code>S</code> 中的元素。然后通过 Hardcore Predicate 产生 Hidden Bits 中的每一个比特位。但是请注意，这里不能直接通过 <code>h(y)=b</code> 来产生 Hidden Bits，因为这样一来 Bob 就能自己算出所有的 Hidden Bits，这违反了上一节的协议。为了保证对 Bob 隐藏，我们需要用公共参考串的原象，也就是 <code>x1, x2, x3, ..., xn</code> 来产生 Hidden Bits，<code>h(x)=b</code>。Bob 虽然不能自己计算 <code>b1, b2, b3, ..., bn</code>，但是一旦得到一个 <code>x</code>，他就能检验 <code>F(x)?=y</code>来判断是否 <code>x</code> 是和公共参考串对应，同时再计算 <code>h(x)=b</code> 得到被揭示的 Hidden Bits，<code>b</code>。</p>
<p>我们可以换一种不太准确，但是更直观的方式来理解，Alice 相当于自己产生一对公私钥。然后Alice 把公共参考串看成是一段「密文」，由于 Alice 有私钥，于是可以对密文进行解密，得到明文，这些明文，对于 Bob 而言就相当于是 Hidden Bits。当 Alice 要「揭示」Hidden Bits 时，就出示相应的明文片段，并且带上公钥，那么 Bob 就能通过公钥再次「加密」明文，与公共参考串的密文进行比对，确保 Alice 没有在揭示过程作弊。</p>
<p>下面是升级后的协议：</p>
<p><strong>对于证明者 Alice</strong>：</p>
<ol>
<li>Alice 随机选择一个 Trapdoor Permutation，<code>(F, h, t)</code></li>
<li>根据公共参考串中的每一个 <code>yi</code>，利用陷门反向计算出 <code>xi = F^(-1)(t, yi)</code></li>
<li>计算 Hidden Bits，<code>bi=h(xi)</code></li>
<li>根据上一节的协议产生证明。假设 Alice 要揭示的 Hidden bits 的位置集合为 <code>r1,r2,...,rl</code>，那么 Alice 向 Bob 发送对应位置的 <code>x</code>，分别为 <code>x_r1, x_r2, x_r3, ... x_rl</code> ，连同<code>(F, h)</code>，和证明一起并发给 Bob。</li>
</ol>
<p><strong>对于验证者 Bob</strong>：</p>
<ol>
<li>检查 <code>(F, h)</code> 是否为一个合法的 Trapdoor Permutation。</li>
<li>对 <code>L</code> 中的每一个元素 <code>x_r</code>，计算出被揭示的 Hidden Bits <code>bi=h(F(x_r))</code>，然后按照上一节的协议检查证明。</li>
</ol>
<p>这个新协议的「完备性」，请大家自行检查。</p>
<p>对于「零知识」，我们需要构造一个「模拟器」Zlice2，它的超能力是修改公共参考串。</p>
<ol>
<li>模拟器直接调用上一节协议的模拟器 Zlice。得到一个三元组，<code>(proof, {r}, {b})</code></li>
<li>对于每一个公共参考串位置，如果它对应某一个 <code>r</code>，模拟器从集合 <code>S</code> 中<strong>随机</strong>选择一个 <code>x_r</code>，使得 <code>h(x_r)=b_r</code>，这里 <code>b_r</code>就是 <code>{b}</code>中对应 <code>r</code> ；然后把 <code>y_r=F(x_r)</code> 作为假参考串的一部分。</li>
<li>对于每一个公共参考串位置，如果与 <code>{r}</code>无关，那么模拟器随机选一个 <code>y</code>即可</li>
<li>模拟器把所有的 <code>y</code>拼在一起，得到一个假CRS。</li>
</ol>
<p>对于「可靠性」，事情变得不那么简单了。因为现在 Alice 有能力挑选 <code>(F,h,t)</code>，Alice 可以挑选一个对自己有利，甚至作弊的 <code>(F, h, t)</code>，使得她可以控制一次协议运行的 Hidden Bits <code>{b}</code>的结果。对于本节升级后的新协议而言，需要重复很多遍，以致于虽然 Alice 可以控制一次协议运行的 Hidden Bits，但是她对其它若干次协议运行的 Hidden Bits 无能为力。换句话说，Alice 无论如何挑选 <code>(F, h, t)</code> 都无法完全掌控多次的协议运行。</p>
<p>这个升级变换理论上可以支持任意的 Hidden Bits 模型下的非交互式零知识证明，被称为 FLS Protocol。FLS 变换有很多的好处：首先，这个随机产生的 CRS 可以多次使用，实现所谓的「Multi-Theorem NIZK」；其次，可以实现「Adaptive Soundness」，即 Alice 可以先看到 CRS，然后再选择要证明的内容。最后，这个协议还是「Adaptive Zero-Knowledge」，即 Bob 也可以先看到 CRS，然后再选择要证明的内容给 Alice。</p>
<p><em>注：Adaptive Adversary 是比较符合现实世界的安全情况，比如第二类CCA安全。因为 CRS 是公开的，攻击者可以先分析 CRS，再决定如何发起攻击。</em></p>
<h2 id="寻找理想的-trapdoor-permutation"><a class="header" href="#寻找理想的-trapdoor-permutation">寻找理想的 Trapdoor Permutation</a></h2>
<p>陷门置换 Trapdoor Permutation 最早出现在姚期智老师的论文「Theory and Application of Trapdoor Functions」[Yao82]中，是公钥密码学的重要基础。在上一节给出的 FLS 变换中，需要一个理想化的 Trapdoor Permutation，所谓的理想化是指，每一个 n-bit 字符串都能唯一变成另一个 n-bit 字符串，并且不会出现「多对一」的映射关系。Alice 需要随机抽样一个 Index，发给 Bob，然后 Bob 要能检查出这个 Index 所对应的 <code>F()</code> 是否是一个「完美」的置换。问题来了，怎么 Bob 怎么能在多项式时间内检查出来呢？如果 Bob 不能检查，那么 Alice 就可以抽样一个不完美的 Permutation（比如一个「多对一」的函数），从而可能作弊，破坏「Soundness」这个性质，Bellare 和 Yung 发表在 1996 年的论文最早注意到了这一点，但是并没有完全解决这个问题[BY96]。</p>
<p>如何找到一个桥梁，能够将 Trapdoor Permutation 合适地抽象出来，同时能够对接到密码学工具的实现上，是一个及其有挑战性的工作。随后各路密码学家（包括 Oded Goldreich） 在这方面研究了很长时间，发表了许许多多的论文 ，各种不同类型的 Trapdoor Permutation 被定义、被研究，但是仍然不能让人满意。直到最近（2018年）一个工作是 Ran Canetti 与 Amit Lichtenberg 提出了 Certifiable Injective Trapdoor Function 这样一个新类型[RL18]，并证明了这种 Trapdoor Permutation 终于能满足 FLS 变换要求。但这是不是故事的结束呢？理论密码学家们估计不会停下探索的脚步。</p>
<p>除了基于 Trapdoor Permutation 的 FLS 变换 ，还有各式各样的解决方案来升级 Hidden Bits Model，比如采用 Invariant Signature[BG90]，或 Verifiable Random Generator [DN00] 来实现 Hidden Bits 的变换，或者弱可验证随机函数 [BGRV09]， 还有一种叫做 publicly-verifiable trapdoor predicates 的方案[CHK03]。</p>
<p>三十年来，密码学家们发明的 NIZK 方案有很多，但 Hidden Bits 方法是目前已知唯一的办法，(1) 基于「一致性分布」的共享 CRS，(2) 实现任意 NP 语言的 NIZK Proofs（Not Arguments!）。</p>
<h2 id="nizk-proofs--与-nizk-arguments"><a class="header" href="#nizk-proofs--与-nizk-arguments">NIZK Proofs  与 NIZK Arguments</a></h2>
<p>在本文中，我们构造的 NIZK 「证明」系统的可靠性属于「Statistical Soundness」，而零知识则属于「Computational Zero-Knowledge」。这意味着什么呢？这意味着，不管证明者 Alice 的算力有多强大（甚至超多项式），Alice 仍然无法作弊。但是，如果验证者 Bob 拥有超强的计算能力，那么是存在这种可能性：Bob 从证明中抽取到有价值的「知识」。</p>
<p>这又意味着什么？</p>
<p>这意味着，对于 NIZK Proofs 来说，它的长度肯定要比「知识」长，知识即 <code>NP</code> 问题中的 <code>witness</code>。只要 Bob 算力够强，他就可以把证明解密。对于「抽取器」而言，它也需要在没有交互的情况下抽取 <code>witness</code> 。证明最短的 NIZK Proofs 当属 Greg Gentry 等人采用「全同态加密」技术构造的 NIZK 方案了 [GGI+14]，证明长度只是稍稍大于 witness 的长度。</p>
<p>那能不能构造证明尺寸小于 witness 的 NIZK 呢？答案是 YES！</p>
<p>还有一类的 NIZK 系统被称为 NIZK Arguments：它们的可靠性是「Computational Soundness」，零知识属于「Perfect Zero-Knowledge」或者「Statistical Zero-Knowledge」。这说明，Alice 如果算力超强，那么她是有作弊空间的，但是因为现实世界中，我们可以通过加大安全参数（Security Parameters）来极大地降低 Alice 作弊的可能性，但是能实现非常极致的零知识特性。由于弱化了可靠性，那么我们就可以继续压缩证明的尺寸。</p>
<p><em>注：在本系列中，我们并不刻意区分「证明」与「论证」这两个词。如果需要指明 Arguments 而非 Proofs，会专门强调。</em></p>
<p>假如说我们要公开一个 NIZK 证明到 Github上，假如过了一百年以后，Github 网站还在，而未来计算机的计算能力已经有了质的飞跃，这时候，一个 NIZK Proof 可能会被算力攻破，泄露知识，而 NIZK Argument 则很大可能性上还保持安全性。</p>
<p>现在流行的热词 —— zkSNARK 中的 <code>AR</code>正是指代 Argument。</p>
<p>NIZK Argument 可以实现 <code>O(1)</code> 常数级长度的证明，即与 <code>witness</code> 的长度无关。然而这需要隐藏更多的秘密到 CRS 中。</p>
<h2 id="没有秘密的世界"><a class="header" href="#没有秘密的世界">没有秘密的世界</a></h2>
<p>1956 年，哥德尔在一封寄给冯诺依曼的信中提到了一个著名的问题，「P 是否等于 NP」。后来，这个问题被 Clay 研究所列为七个千禧年难题之一，悬赏百万美金。</p>
<p>零知识证明系统正是为了保护 witness 不泄露的前提下，实现 <code>NP</code> 问题的验证。那如果一旦证明了「P == NP」，这会意味着什么？这意味着 witness 不再有多大意义了，反正一个图灵机也可以在多项式时间内找到 witness。零知识证明试图保护的 witness 也变得徒劳无益。</p>
<p>事实上，如果「P == NP」，现有的公钥密码学、对称加密 AES 与 SM4、哈希算法所依赖的难解问题都可能坍塌，我们可能很难保存秘密。不仅如此，</p>
<blockquote>
<p>如果 P == NP，我们所处的世界将会变得非常不一样。「Creative Leaps」将不再有价值，求解问题与验证问题之间的鸿沟不复存在。每个能欣赏交响乐的人都会成为莫扎特，每个会推理的人都会变成高斯，每个能判断投资好坏的人都会变成巴菲特。从达尔文进化论的观点出发：如果这就是我们存在的宇宙，为什么我们还没有进化得可以充分利用这个好处？—— Scott Aaronson (2006)</p>
</blockquote>
<p>对于数学也一样，数学证明的验证过程也是多项式复杂度的，如果「P == NP」，那么也就存在着多项式时间寻找证明的算法（如果证明存在）。这意味着哥德巴赫猜想、黎曼猜想将有可能得到证明，难怪 Lance Fortnow 在博客[For04]里这么说：</p>
<blockquote>
<p>A person who proves P == NP would walk home from the Clay Institute not with one million-dollar check but with seven. 如果谁能证明 P = NP，那么他不会只拿着一张百万美元支票回家，而是七张。  —— Lance Fortnow (2004)</p>
</blockquote>
<p>2002年的调查显示，61% 的计算机科学家相信「P != NP」，而十年后，这个比例上升到了 83%[Wil12]。 而我是被 Scott Aaronson 的如下论断说服的：</p>
<blockquote>
<p>自指论证：如果 P = NP 是事实，那么这个证明会比较容易被发现；但是如果 P != NP，那么这个证明会比较难发现。所以相信 P != NP 看起来会让 <strong>数学现实</strong> 更一致一些。—— Scott Aaronson (2006)</p>
</blockquote>
<p>尽管是如此不情愿，如果我们真的生活在一个没有秘密的世界，那会是什么样子？「环形监狱 Panopticon」是 18 世纪英国哲学家 Jeremy Bentham 提出的一个惊悚概念。囚徒们被中心全天候监控，没有任何隐私可言，而且他们对自己是否处于被监控状态也无从得知。这个无比悲观的论调让人浑身不适，但很多人认为，这可能是两百多年前对未来网络数字时代的一则精准寓言。</p>
<p><img src="img/panopticon.png" alt="" /></p>
<p>从『Billy Budd』，卡夫卡的『The Trial』，到奥威尔的『1984』，到著名黑客 Kevin Mitnick 写的超级大卖书『隐形的艺术』（教你如何在大数据时代保护自己的信息），似乎，危机四伏，风险不断累积，对末日世界的想象给了作家们很好的素材  ……</p>
<p>偶尔无意中看到了一本有趣的漫画『The Private Eye』，它描述了一个劫后余生的后现代场景：在未来，我们的所有信息数据都存放在云上，然后突然有一天，这个数据云「爆炸」了，不知道是什么原因（可能是谁不小心打开了潘多拉的魔盒，找到了 P == NP 的构造性证明），反正所有的信息，包括每个人最阴暗的过去，都不再成为秘密；所有的数字化的资产都被抹掉，所有的在线知识库永久丢失；每个人的言行、账单、邮件、聊天消息、银行卡密码、中学考卷、GPS位置信息，写了一半的日记、删除的照片、上网记录，这些信息都将暴露给同事、邻居、 朋友、亲人、甚至任何一个好奇的人。</p>
<p><img src="img/private_eye.png" alt="" /></p>
<p>每个人都无地自容，惶惶不可终日，然后逐渐地，大家都选择隐藏自己，人们出门都要戴上面具，以小心翼翼地保护自己的身份，甚至一个人可以选择使用多个身份，国家法律规定任何偷窥行为都将被严惩，获取信息成为了一种至少无上的权力，照相机需要被严格管控，互联网不再存在，人们通讯又回到了电话亭时代 ……</p>
<p>这会是人类的终极命运么？</p>
<h2 id="未完待续"><a class="header" href="#未完待续">未完待续</a></h2>
<p>本文开头提到了「隐藏随机性」并不是必要的，我们来回想下 Hidden Bits 模型。这些 Hidden Bits 并没有对 Prover 隐藏，而是敞开了让 Prover 知道，但是由于 Hidden Bits 是「一致性随机分布」的字符串， 所以即使让 Prover 知道了，他仍然逃不过随机挑战的火力。然而在流行的 zkSNARK 方案中，并没有采用「一致性随机分布」的 CRS，而是一组结构化的随机数。不管怎样，用 CRS 来构建「信任根基」的秘密，就是藏在其中的「秘密」。</p>
<p>这符合直觉，保守「秘密」也是一种信任。因为 Alice 不知道 CRS 中隐藏的秘密后门，所以无法作弊。同样，Bob 不知道 CRS 中的秘密，也就没办法获得「知识」。同样，人与人之间的协作既要建立在公开透明的基础上，也要保守秘密。</p>
<blockquote>
<p>All human beings have three lives: public, private, and secret. 每个人都有三种生活，公开的，私人的，以及秘密的。—— Gabriel García Márqueel</p>
</blockquote>
<p><em>致谢：感谢陈宇，丁晟超，张宇鹏，胡红钢，刘巍然，何德彪，万志国等老师的专业建议和指正，感谢安比实验室小伙伴（p0n1, even, valuka, Vawheter, yghu, mr）的修改建议。本文内容不代表他们观点。</em></p>
<p>最后附上漫画书的链接：<a href="http://panelsyndicate.com/comics/tpeye">http://panelsyndicate.com/comics/tpeye</a> 作者甚至把创作过程的邮件和草图都放了出来，大家可以体验一下窥视制作过程的快感。</p>
<h3 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h3>
<ul>
<li>[Aar06] Aaronson, Scott. <em>Reasons to believe</em>, 2006. https://www.scottaaronson.com/blog/?p=122</li>
<li>[BFM88] Blum, Manuel, Paul Feldman, and Silvio Micali. “Non-interactive zero-knowledge and its applications.” STOC’88. 1988.</li>
<li>[BG90] Bellare, Mihir, and Shafi Goldwasser. “New paradigms for digital signatures and message authentication based on non-interactive zero knowledge proofs.” <em>Conference on the Theory and Application of Cryptology</em>. Springer, New York, NY, 1989.</li>
<li>[BGN05] Boneh, Dan, Eu-Jin Goh, and Kobbi Nissim. “Evaluating 2-DNF formulas on ciphertexts.” <em>Theory of Cryptography Conference</em>. Springer, Berlin, Heidelberg, 2005.</li>
<li>[BGRV09] Brakerski, Zvika, Shafi Goldwasser, Guy N. Rothblum, and Vinod Vaikuntanathan. “Weak verifiable random functions.” In <em>Theory of Cryptography Conference</em>, pp. 558-576. Springer, Berlin, Heidelberg, 2009.</li>
<li>[BY96] Bellare, Mihir, and Moti Yung. “Certifying permutations: Noninteractive zero-knowledge based on any trapdoor permutation.” <em>Journal of Cryptology</em> 9.3 (1996): 149-166.</li>
<li>[CHK03] Canetti, Ran, Shai Halevi, and Jonathan Katz. “A forward-secure public-key encryption scheme.” <em>International Conference on the Theory and Applications of Cryptographic Techniques</em>. Springer, Berlin, Heidelberg, 2003.</li>
<li>[CHMMVW19] Chiesa, Alessandro, et al. <em>Marlin: Preprocessing zksnarks with universal and updatable srs</em>. Cryptology ePrint Archive, Report 2019/1047, 2019, https://eprint.iacr.org/2019/1047, 2019.</li>
<li>[DN00] Dwork, Cynthia, and Moni Naor. “Zaps and their applications.” <em>Proceedings 41st Annual Symposium on Foundations of Computer Science</em>. IEEE, 2000.</li>
<li>[FLS90] Feige, Uriel, Dror Lapidot, and Adi Shamir. “Multiple non-interactive zero knowledge proofs based on a single random string.” <em>Proceedings [1990] 31st Annual Symposium on Foundations of Computer Science</em>. IEEE, 1990.</li>
<li>[For04] Fortnow, Lance. “What if P = NP?”. 2004. https://blog.computationalcomplexity.org/2004/05/what-if-p-np.html</li>
<li>[For09] Fortnow, Lance. “The status of the P versus NP problem.” <em>Communications of the ACM</em> 52.9 (2009): 78-86.</li>
<li>[Groth10a] Groth, Jens. “Short non-interactive zero-knowledge proofs.” <em>International Conference on the Theory and Application of Cryptology and Information Security</em>. Springer, Berlin, Heidelberg, 2010.</li>
<li>[Groth10b] Groth, Jens. “Short pairing-based non-interactive zero-knowledge arguments.” <em>International Conference on the Theory and Application of Cryptology and Information Security</em>. Springer, Berlin, Heidelberg, 2010.</li>
<li>[GOS06] Groth, Jens, Rafail Ostrovsky, and Amit Sahai. “Perfect non-interactive zero knowledge for NP.” <em>Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. Springer, Berlin, Heidelberg, 2006.</li>
<li>[GWC19] Gabizon, Ariel, Zachary J. Williamson, and Oana Ciobotaru. <em>PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</em>. Cryptology ePrint Archive, Report 2019/953, 2019.</li>
<li>[KP98] Kilian, Joe, and Erez Petrank. “An efficient noninteractive zero-knowledge proof system for NP with general assumptions.” <em>Journal of Cryptology</em> 11.1 (1998): 1-27.</li>
<li>[MBK+19] Maller, Mary, et al. “Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updateable Structured Reference Strings.” <em>IACR Cryptology ePrint Archive</em> 2019 (2019): 99.</li>
<li>[RL18] Ran Canetti and Amit Lichtenberg. “Certifying trapdoor permutations, revisited.” <em>Theory of Cryptography Conference</em>. Springer, Cham, 2018.</li>
<li>[Wil12]Gasarch, William I. “Guest Column: The Third P=? NP Poll.” <em>ACM SIGACT News</em> 50.1 (2019): 38-59.</li>
<li>[Yao82] Yao, Andrew C. “Theory and application of trapdoor functions.” <em>23rd Annual Symposium on Foundations of Computer Science (sfcs 1982)</em>. IEEE, 1982.</li>
</ul>
<footer id="open-on-gh">Found a bug?! <a href="https://github.com/zkp-co-learning/zkp-co-learning.github.io/edit/main/src/zkp-intro/5/zkp-crs.md">Edit this page on GitHub.</a></footer>
                        <hr>
                        <div class="giscus"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../zkp-intro/4/zkp-rom.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../zk-snarks/toc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../zkp-intro/4/zkp-rom.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../zk-snarks/toc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/mermaid.min.js"></script>
        <script src="../../theme/mermaid-init.js"></script>


    </div>

    <script type="text/javascript">
        var langs = [
            'cn',
            'en',
        ];

        (function initLangs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

            // For each language, update the link to point to the current page in that language
            let linkParts = window.location.pathname.split('/');
            let langIndex = linkParts.findIndex((s) => langs.includes(s));
            langs.forEach(function (lang) {
                var link = document.getElementById('lang-' + lang);
                if (!link) {
                    return;
                }

                let newLinkParts = linkParts.slice();

                // If it is Chinese, remove the current language from the path
                if (lang === "cn") {
                    if (langIndex !== -1) {
                        newLinkParts.splice(langIndex, 1);
                    }
                }
                
                // Otherwise, add the new language to the path
                else {
                    if (langIndex === -1) {
                        // Modify this line to insert the language right after the domain
                        newLinkParts.splice(1, 0, lang);
                    } else {
                        newLinkParts[langIndex] = lang;
                    }
                }

                link.href = newLinkParts.join('/');
            });
        })();

        </script>
        <script src="https://giscus.app/client.js"
                data-repo="zkp-co-learning/zkp-co-learning.github.io"
                data-repo-id="R_kgDOKNpxMQ"
                data-category="Announcements"
                data-category-id="DIC_kwDOKNpxMc4CZ2LA"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="zh-CN"
                crossorigin="anonymous"
                async>
        </script>
    </body>
</html>
