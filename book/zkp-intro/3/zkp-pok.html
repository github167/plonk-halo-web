<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>（三）寻找「知识」 - World of Z2O-K7E</title>


        <!-- Custom HTML head -->
        <meta property="og:title" content="zkp-intro/3/zkp-pok.md" />
        <meta name="description" content="零知世界, Halo2 Tutorial, world of Zero-knowledge proof, Halo2 教程">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././mdbook-admonish.css">
        <link rel="stylesheet" href="../../theme/css/mdbook-admonish.css">
        <link rel="stylesheet" href="../../theme/css/open-in.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../index.html">🌟 About z2o-k7e  /zu:ˈki:/</a></li><li class="chapter-item affix "><a href="../../vision.html">🚩 Our Vision & Roadmap</a></li><li class="chapter-item affix "><a href="../../how-to-contribute.html">📖 How-to-contribute</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item affix "><a href="../../beginner.html">ZKP 新手村入门攻略</a></li><li class="chapter-item affix "><a href="../../zk-everything/zk-everything-Jade/Hello_ZKP.html">Hello ZKP</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item expanded "><a href="../../zkp-intro/toc.html">探索零知识证明系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zkp-intro/1/zkp-back.html">（一）初识「零知识」与「证明」</a></li><li class="chapter-item "><a href="../../zkp-intro/2/zkp-simu.html">（二）理解「模拟」</a></li><li class="chapter-item expanded "><a href="../../zkp-intro/3/zkp-pok.html" class="active">（三）寻找「知识」</a></li><li class="chapter-item "><a href="../../zkp-intro/4/zkp-rom.html">（四）随机「挑战」</a></li><li class="chapter-item "><a href="../../zkp-intro/5/zkp-crs.html">（五）埋藏「秘密」</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../zk-snarks/toc.html">从零开始学习 zk-SNARK</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zk-snarks/1-Polynomial-Interaction-and-Proof.html">1-Polynomial-Interaction-and-Proof</a></li><li class="chapter-item "><a href="../../zk-snarks/2-Non-interactivity&Distributed-Setup.html">2-Non-interactivity&Distributed-Setup</a></li><li class="chapter-item "><a href="../../zk-snarks/3-General-Purpose-Computation.html">3-General-Purpose-Computation</a></li><li class="chapter-item "><a href="../../zk-snarks/4-Construction-Properties.html">4-Construction-Properties.md</a></li><li class="chapter-item "><a href="../../zk-snarks/5-Pinocchio-Protocol.html">5-Pinocchio-Protocol</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-intro.html">理解 Plonk 系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-arithmetization.html">1-Plonkish Arithmetization</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-lagrange-basis.html">2-多项式编码</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-permutation.html">3-置换证明</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-constraints.html">4-算术约束与拷贝约束</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-polycom.html">5-多项式承诺</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-randomizing.html">6-实现 Zero Knowledge</a></li><li class="chapter-item "><a href="../../plonk-intro-cn/plonk-lookup.html">7-Lookup Gate</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../lasso-zh/lasso-intro.html">理解 Lasso 系列</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../lasso-zh/lasso-0.html">理解 Lasso（零）：带索引的查询证明</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-1.html">理解 Lasso（一）：Offline Memory Checking</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-2.html">理解 Lasso (二)：稀疏向量与 Tensor 结构</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-3.html">理解 Lasso (三)：大表格的稀疏查询证明</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-4.html">理解 Lasso (四)：更多的可分解表格</a></li><li class="chapter-item "><a href="../../lasso-zh/lasso-5.html">理解 Lasso (五)：表格的 MLE 结构</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../halo2/halo2.html">Halo2 Tutorial</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../halo2/chap-0/index.html">1-basic concepts</a></li><li class="chapter-item "><a href="../../halo2/chap-1/index.html">2-simple-circuit</a></li><li class="chapter-item "><a href="../../halo2/chap-2/index.html">3-custom-gate</a></li><li class="chapter-item "><a href="../../halo2/chap-3/index.html">4-fibonacci</a></li><li class="chapter-item "><a href="../../halo2/chap-4/index.html">5-range-check</a></li><li class="chapter-item "><a href="../../halo2/cost-model.html">6-cost-model</a></li><li class="chapter-item "><a href="../../halo2/halo2-QA.html">halo2-QA</a></li><li class="chapter-item "><a href="../../halo2/tmp/halo2-learning-materials.html">halo2-learning-materials</a></li><li class="chapter-item "><a href="../../halo2/tmp/halo2-learning-materials.html">learning-halo2 (0xPARC)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../halo2/tmp/1-Simple-Example.html">1-Simple Examples</a></li><li class="chapter-item "><a href="../../halo2/tmp/2-Fibonacci-example-1.html">2-Fibonacci-example-1</a></li><li class="chapter-item "><a href="../../halo2/tmp/3-Fibonacci-example-2.html">3-Fibonacci-example-2</a></li><li class="chapter-item "><a href="../../halo2/tmp/4-IsZero-Check-example-3.html">4-IsZero Check-example-3</a></li><li class="chapter-item "><a href="../../halo2/tmp/5-Range-check.html">5-Range check-example-1.md</a></li><li class="chapter-item "><a href="../../halo2/tmp/6-Range-Check(code-explanation).html">6-Range Check (code explanation)</a></li><li class="chapter-item "><a href="../../halo2/tmp/7-Range-Check-lookup(example-2).html">7-Range Check-Lookup-example-2)</a></li><li class="chapter-item "><a href="../../halo2/tmp/8-Range-Check(example-3).html">8-Range Check-Lookup-example-3)</a></li><li class="chapter-item "><a href="../../halo2/tmp/9-decomposed.html">9-Range Check-Decompose)</a></li><li class="chapter-item "><a href="../../halo2/tmp/ZKP-APP.html">ZKP Apps with halo2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../halo2/tmp/Zordle.html">Zordle</a></li><li class="chapter-item "><a href="../../halo2/tmp/Hammster.html">Hammster</a></li></ol></li></ol></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-1-Basic.html">Lattice-based Crypography</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-1-Basic.html">Lattice-1-Basic</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-2-LLL.html">Lattice-2-LLL</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-3-CVP.html">Lattice-3-CVP</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-Xor0v0/Lattice-4-RSA.html">Lattice-4-RSA</a></li></ol></li><li class="chapter-item "><a href="../../zkp-QA.html">Recurrent Q&A</a></li><li class="chapter-item "><a href="../../zk-everything/toc.html">zk-everything</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zk-everything/BabySNARK tutorial.html">BabySNARK tutorial</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/KZG.html">KZG</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture1:Overview about Zeroknowledge.html">Lecture1:Overview about Zeroknowledge</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture2:Introduction to Modern SNARKs.html">Lecture2:Introduction to Modern SNARKs</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture12:ZKEVM.html">Lecture12:ZKEVM</a></li><li class="chapter-item "><a href="../../zk-everything/zk-learning-miles/Lecture16:Hardware acceleration.html">Lecture16:Hardware acceleration</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/GKR_with_ZK_Argument.html">Spartan preliminary: GKR with ZK Argument</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/Hyrax.html">Spartan preliminary: Hyrax</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/Spartan.html">Spartan In Depth</a></li><li class="chapter-item "><a href="../../zk-everything/zk-everything-joe/Theory_and_Practical_Implementation_of_BLS12-381.html">BLS12-381 理论与实现</a></li><li class="chapter-item "><a href="../../Nova/SuperNova.html">SuperNova</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../public goods/toc.html">ZKP Public Goods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../public goods/第二章.html">ch2</a></li><li class="chapter-item "><a href="../../public goods/4-Proving-System.html">ch4-Proving System</a></li><li class="chapter-item "><a href="../../public goods/5-plonk-intro.html">ch5-plonk-intro</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../materials/ZK-Materials.html">ZK Materials</a></li><li class="chapter-item affix "><li class="spacer"></li><li class="chapter-item "><a href="../../exp/toc.html">经验心得</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../exp/guoyu.html">郭宇：ZK 技术的学习心得和经验分享</a></li><li class="chapter-item "><a href="../../exp/freeyao.html">对话姚翔：解读零知识证明的前世今生</a></li><li class="chapter-item "><a href="../../https://zhuanlan.zhihu.com/p/268305208.html">邓燚：零知识，模拟与归约（一个个人化的视角）</a></li></ol></li><li class="chapter-item "><li class="spacer"></li><li class="chapter-item "><a href="../../zkp-space/toc.html">ZKP Space</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../zkp-space/2023-10-22-zkp-coprocessor.html">2023.10.12: 聊聊 ZKP Coprocessor</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">World of Z2O-K7E</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change Language" aria-label="Change Language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme"><a id="lang-cn">中文</a></button></li>
                            <li role="none"><button role="menuitem" class="theme"><a id="lang-en">English</a></button></li>
                        </ul>
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/zkp-co-learning/zkp-co-learning.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/zkp-co-learning/zkp-co-learning.github.io/edit/main/src/zkp-intro/3/zkp-pok.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="寻找知识"><a class="header" href="#寻找知识">寻找「知识」</a></h1>
<p><em>探索零知识证明系列（三）</em></p>
<ul>
<li><a href="#%E9%9B%B6%E7%9F%A5%E8%AF%86vs-%E5%8F%AF%E9%9D%A0%E6%80%A7">「零知识」vs. 「可靠性」</a></li>
<li><a href="#%E7%AE%80%E6%B4%81%E7%9A%84-schnorr-%E5%8D%8F%E8%AE%AE">简洁的 Schnorr 协议</a>
<ul>
<li><a href="#%E8%AF%81%E6%98%8E%E9%9B%B6%E7%9F%A5%E8%AF%86">证明零知识</a></li>
<li><a href="#%E5%86%8D%E9%81%87%E6%A8%A1%E6%8B%9F%E5%99%A8">再遇模拟器</a></li>
<li><a href="#proof-of-knowledge-%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E">Proof of Knowledge ：「知识证明」</a></li>
<li><a href="#%E8%A7%A3%E8%AF%BB-ecdsa-%E7%AD%BE%E5%90%8D%E6%94%BB%E5%87%BB">解读 ECDSA 签名攻击</a></li>
<li><a href="#%E8%84%91%E6%B4%9E%E6%88%91%E4%BB%AC%E7%94%9F%E6%B4%BB%E5%9C%A8%E6%A8%A1%E6%8B%9F%E4%B8%96%E7%95%8C%E4%B8%AD%E5%90%97">脑洞：我们生活在模拟世界中吗</a></li>
<li><a href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD">未完待续</a>
<ul>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>And what, Socrates, is the food of the soul? Surely, I said, knowledge is the food of the soul.  苏格拉底，什么是灵魂的食物？我说过，当然是知识。
—— 柏拉图</p>
</blockquote>
<p>导言：有些理论非常有趣，零知识证明便是其中之一，摸索了许久，想写点什么，与大家一起讨论。本文是『探索零知识证明』系列的第三篇。全文约 8,000 字，少量数学公式。</p>
<p>本文将在 <a href="https://github.com/sec-bit/learning-zkp/">Github</a>   进行更新与修正。</p>
<h2 id="零知识vs-可靠性"><a class="header" href="#零知识vs-可靠性">「零知识」vs. 「可靠性」</a></h2>
<p>我们在许多介绍零知识证明的文章中都能看到这样三个性质：</p>
<ul>
<li>Completeness —— 完备性</li>
<li>Soundness —— 可靠性</li>
<li>Zero-Knowledge —— 零知识</li>
</ul>
<p>但是少有文章深入解释这个特性背后的深意和洞见。</p>
<p>在『<a href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/2/zkp-simu.md">系列（二）理解「模拟」</a>』一文中，我们介绍了「模拟器」这个概念。许多介绍文章也避而不谈「模拟」，但「模拟」可以说是安全协议中核心的核心，因为它是定义「安全性」的重要武器。</p>
<p>通常，我们定义安全会采用这样一种方式，首先列出一些安全事件，然后说明：如果一个系统安全，那么列出来的安全事件都不会发生。</p>
<blockquote>
<p>Rather than giving a list of the events that are <em>not allowed</em> to occur, it (the definition of zero-knowledge proof) gives a maximalist <em>simulation</em> condition.</p>
<p>— Boaz Barak</p>
</blockquote>
<p>借用密码学家 Boaz Barak 的话，翻译一下，「零知识证明」并不是通过给出一个<strong>不允许发生的事件列表</strong>来定义，而是直接给出了一个最极致的「模拟条件」。</p>
<p>所谓「模拟条件」是指，通过「模拟」方法来实现一个「理想世界」，使之与「现实世界」不可区分；而由于在理想世界中不存在知识，所以可以推导出结论：现实世界满足「零知识」。</p>
<p>我们继续分析下一个交互系统（安全协议）的三个性质：「完备性」、「可靠性」与「零知识」。</p>
<blockquote>
<p>可靠性（Soundness）：Alice 在没有知识的情况下不能通过 Bob 的验证。</p>
</blockquote>
<blockquote>
<p>完备性（Completeness）：Alice 在有知识的情况下可以通过 Bob 的验证。</p>
</blockquote>
<blockquote>
<p>零知识（Zero-knowledge）：Alice 在交互的过程中不会泄露关于知识的任何信息。</p>
</blockquote>
<p>我们可以看出来「可靠性」和「完备性」有一种「对称性」。可靠性保证了恶意的 Alice 一定失败，而完备性保证了诚实的 Alice 一定成功。</p>
<p>「完备性」比较容易证明，只要 Alice 诚实，Bob 也诚实，那么皆大欢喜。这好比，写好一段代码，喂了一个测试用例，跑完通过收工。</p>
<p>我们来想想「可靠性」应该如何定义？这个可靠性的逆否命题是：（在现实世界中）如果 Alice 能通过 Bob 的验证，那么 Alice 一定有知识。或者说：Alice 知道那……个「秘密」！</p>
<p>下面的问题是如何证明 Alice 知道一个「秘密」？</p>
<p>这好像也很难，对不对？假如我们需要证明一台机器知道一个「秘密」，最简单的办法就是我们在机器的硬盘里，或者内存中找到这个「秘密」，但是这样暴露了秘密。如果这台机器是黑盒子呢？或者是 Alice 呢？我们没有读心术，猜不到她心里的那个秘密。</p>
<p>如何定义「To Know」？</p>
<p>「零知识」保证了 验证者 Bob 没有（计算）能力来把和「知识」有关的信息「抽取」出来。不能抽取的「知识」不代表不存在。「可靠性」保证了知识的「存在性」。</p>
<blockquote>
<p>只有「知识」在存在的前提下，保证「零知识」才有意义</p>
</blockquote>
<p>本文将探讨「可靠性」和「To Know」。</p>
<hr />
<p>为了进一步分析「知识」，接下来首先介绍一个非常简洁，用途广泛的零知识证明系统 —— Schnorr 协议。这个协议代表了一大类的安全协议，所谓的 Σ-协议，而且 Schnorr 协议扩展也是 <a href="https://github.com/sec-bit/zkPoD-node">零知识数据交换协议 zkPoD</a> [1] 的核心技术之一。</p>
<h1 id="简洁的-schnorr-协议"><a class="header" href="#简洁的-schnorr-协议">简洁的 Schnorr 协议</a></h1>
<p>Alice 拥有一个秘密数字，<code>a</code>，我们可以把这个数字想象成「私钥」，然后把它「映射」到椭圆曲线群上的一个点 <code>a*G</code>，简写为 <code>aG</code>。这个点我们把它当做「公钥」。</p>
<ul>
<li>
<p><code>sk = a</code></p>
</li>
<li>
<p><code>PK = aG</code></p>
</li>
</ul>
<p>请注意「映射」这个词，我们这里先简要介绍「同态」这个概念。椭圆曲线群有限域之间存在着一种同态映射关系。有限域，我们用 <code>Zq</code>这个符号表示，其中素数 <code>q</code>是指有限域的大小，它是指从 <code>0, 1, 2, …, q-1</code> 这样一个整数集合。而在一条椭圆曲线上，我们通过一个基点，<code>G</code>，可以产生一个「循环群」，标记为 <code>0G, G, 2G, …, (q-1)G</code>，正好是数量为 <code>q</code>个 曲线点的集合。任意两个曲线点正好可以进行一种「特殊的二元运算」，<code>G + G = 2G</code>，<code>2G + 3G = 5G</code>，看起来这个二元运算好像和「加法」类似，满足交换律和结合律。于是我们就用 <code>+</code>这个符号来表示。之所以把这个群称为循环群，因为把群的最后一个元素 <code>(q-1)G</code>，再加上一个 <code>G</code>就回卷到群的第一个元素 <code>0G</code>。</p>
<p>给任意一个有限域上的整数 <code>r</code>，我们就可以在循环群中找到一个对应的点 <code>rG</code>，或者用一个标量乘法来表示 <code>r*G</code>。但是反过来计算是很「困难」的，这是一个「密码学难题」—— 被称为离散对数难题[2]。</p>
<p>也就是说，如果任意给一个椭圆曲线循环群上的点 <code>R</code>，那么到底是有限域中的哪一个整数对应 <code>R</code>，这个计算是很难的，如果有限域足够大，比如说 256bit 这么大，我们姑且可以认为这个反向计算是不可能做到的。</p>
<p>Schnorr 协议充分利用了有限域和循环群之间单向映射，实现了最简单的零知识证明安全协议：Alice 向 Bob 证明她拥有 <code>PK</code> 对应的私钥 <code>sk</code>。</p>
<p><img src="img/schnorr.png" alt="" /></p>
<p>第一步：为了保证零知识，Alice 需要先产生一个随机数，<code>r</code>，这个随机数的用途是用来保护私钥无法被 Bob 抽取出来。这个随机数也需要映射到椭圆曲线群上，<code>rG</code>。</p>
<p>第二步：Bob 要提供一个随机数进行挑战，我们把它称为 <code>c</code>。</p>
<p>第三步：Alice 根据挑战数计算 <code>z = r + a * c</code>，同时把 <code>z</code>发给 Bob，Bob通过下面的式子进行检验：</p>
<pre><code>z*G ?= R + c*PK = rG + c*(aG)
</code></pre>
<p>大家可以看到 Bob  在第三步「同态地」检验 <code>z</code> 的计算过程。如果这个式子成立，那么就能证明 Alice 确实有私钥 <code>a</code>。可是，这是为什么呢？</p>
<p><code>z</code> 的计算和验证过程很有趣，有几个关键技巧：</p>
<ol>
<li>首先 Bob 必须给出一个「随机」挑战数，然后 Bob 在椭圆曲线上同态地检查 <code>z</code> 。如果我们把挑战数 <code>c</code> 看成是一个未知数，那么 <code>r+a*c=z</code> 可以看成是一个一元一次方程，其中 <code>r</code> 与 <code>a</code> 是方程系数。请注意在 <code>c</code> 未知的前提下，如果 <code>r + a*x = r' + a'*x</code> 要成立，那么根据 Schwatz-Zippel 定理[3]，极大概率上 <code>r=r'</code>，<code>a=a'</code> 都成立。也就是说， Alice 在 <code>c</code> 未知的前提下，想找到另一对不同的 <code>r'</code>,<code>a'</code> 来计算 <code>z</code> 骗过 Bob 是几乎不可能的。这个随机挑战数 <code>c</code> 实现了<code>r</code> 和 <code>a</code> 的限制。虽然 Bob 随机选了一个数，但是由于 Alice 事先不知道，所以 Alice 不得不使用私钥 <code>a</code> 来计算 <code>z</code>。这里的关键： <code>c</code> 必须是个随机数。</li>
<li>Bob 验证是在椭圆曲线群上完成。Bob 不知道<code>r</code>，但是他知道 <code>r</code> 映射到曲线上的点<code>R</code>；Bob 也不知道 <code>a</code>，但是他知道 <code>a</code> 映射到曲线群上的点 <code>PK</code>，即 <code>a*G</code>。通过同态映射与Schwatz-Zippel 定理，Bob 可以校验 <code>z</code> 的计算过程是否正确，从而知道 Alice 确实是通过 <code>r</code> 和 <code>a</code> 计算得出的 <code>z</code>，但是又不暴露 <code>r</code> 与 <code>a</code> 的值。</li>
<li>还有，在协议第一步中产生的随机数 <code>r</code> 保证了 <code>a</code> 的保密性。因为任何一个秘密当和一个符合「一致性分布」的随机数相加之后的和仍然符合「一致性分布」。</li>
</ol>
<h2 id="证明零知识"><a class="header" href="#证明零知识">证明零知识</a></h2>
<p>我们这里看一下 Schnorr 协议如何证明一个弱一些的「零知识」性质——「SHVZK」：</p>
<p>注：这里我们证明的仅仅是 Special Honest Verifier Zero-Knowledge（SHVZK）。SHVZK 要求协议中的 Bob 的行为不能不按常理出牌，比如他必须按协议约定，在第二步时，去传送带上取一个新鲜的随机数，并且立即使用。而通常意义上的「零知识」是不会对 Bob 做任何要求，所以我们说这里是一个弱一些的性质。虽然目前 Schnorr 协议不能证明完全的「零知识」，但经过添加一些协议步骤，就可以达到完全零知识的目的，细节这里不展开，有兴趣的读者请参考文献[4]。以后我们在讨论 Fiat-Shamir 变换时，还会再次讨论这个问题。</p>
<p>首先「模拟器」模拟一个「理想世界」，在理想世界中模拟出一个 Zlice 和 Bob 对话，Zlice 没有 Schnorr 协议中的知识，<code>sk</code>，而 Bob 是有公钥 <code>PK</code>的。请大家看下图，Bob 需要在 Schnorr 协议中的第二步出示一个随机数 <code>c</code>，这里有个额外的要求， 就是 Bob 只能「诚实地」从一个外部「随机数传送带」上拿一个随机数，每一个随机数都必须是事先抛k次「硬币」产生的一个 <code>2^k</code> 范围内的一次性分布随机数。Bob 不能采用任何别的方式产生随机数，这就是为何我们要求 Bob 是诚实的。</p>
<p>下面演示 Zlice 如何骗过 Bob：</p>
<p><img src="img/schnorr-sim-1.png" alt="" /></p>
<p>序幕：请注意 Zlice 没有关于<code>sk</code>的知识，这时 Bob 的随机数传送带上已经预先放置了一些随机数。</p>
<p><img src="img/schnorr-sim-2.png" alt="" /></p>
<p>第一步：Zlice 产生一个一致性分布的随机数<code>c</code>，并且利用一个新的「超能力」，将刚刚产生的随机数 <code>c</code> 替换掉 Bob 的随机数传送带上第一个随机数。这时候，Bob 无法察觉。</p>
<p><img src="img/schnorr-sim-3.png" alt="" /></p>
<p>第二步：Zlice 再次产生一个随机数 <code>z</code>，然后计算 <code>R'=z*G - c*PK</code>，并将 <code>R'</code>发送给 Bob。</p>
<p><img src="img/schnorr-sim-4.png" alt="" /></p>
<p>第三步：这时候Bob 会从随机数传送带上取得 <code>c</code>，并且将 <code>c</code> 发送给 Zlice。请注意这个<code>c</code> 正好就是第一步中 Zlice 产生的 <code>c</code>。</p>
<p><img src="img/schnorr-sim-5.png" alt="" /></p>
<p>第四步：Zlice 将第三步产生的随机数 <code>z</code> 发送给 Bob，Bob 按照 Schnorr 协议的验证公式进行验证，大家可以检查下，这个公式完美成立。</p>
<p>大家可以再对比下「现实世界」的 Schnorr 协议，在两个世界中，Bob 都能通过验证。</p>
<p><img src="img/schnorr.png" alt="" /></p>
<p>但区别是：</p>
<ul>
<li>在「理想世界中」，Zlice 没有 <code>sk</code>；而在「现实世界中」，Alice 有 <code>sk</code></li>
<li>在「理想世界中」，<code>z</code> 是一个随机数，没有涉及 <code>sk</code>；而在「现实世界中」，<code>z</code> 的计算过程里面包含 <code>sk</code></li>
<li>在「理想世界中」，Zlice 使用了超能力，替换了 Bob 的随机数；而在「现实世界中」，Alice 看不到 Bob 的随机数传送带，也无法更改传送带上的数字</li>
</ul>
<p>这里请大家思考下：Schnorr 协议中，Bob 在第二步发挑战数能不能和第一步对调顺序？也就是说 Bob 能不能先发挑战数，然后 Alice 再发送 <code>R = r*G</code>。</p>
<p>（两分钟后……）</p>
<p>答案是不能。</p>
<p>如果 Alice 能提前知道随机数，那么 （现实世界中的）Alice 就可以按照模拟器 Zlice 做法来欺骗 Bob。</p>
<h2 id="再遇模拟器"><a class="header" href="#再遇模拟器">再遇模拟器</a></h2>
<p>其实，「可靠性」和「零知识」这两个性质在另一个维度上也是存在着一种对称性。可靠性保证了恶意的 Alice 一定失败，零知识保证了恶意的 Bob （窃取知识）一定不会成功。有趣地是，这种对称性将体现在模拟出来的「理想世界」中。</p>
<p>我们分析下可靠性这个定义：Alice 没有知识 <strong>导致</strong> Bob 验证失败。它的逆否命题为：Bob 验证成功 <strong>导致</strong> Alice 一定有知识。</p>
<p><strong>我们再次求助模拟器</strong>，让他在可以发挥超能力的「理想世界」中，去检验 Alice 的知识。</p>
<p>再次，请大家设想在平行宇宙中，有两个世界，一个是叫做「理想世界」，另一个叫做「现实世界」。理想世界有趣的地方在于它是被「模拟器」模拟出来的，同时模拟器可以在理想世界中放入带有超能力的 NPC。这次把 Alice 的两个分身同时放入「理想世界」与「现实世界」。</p>
<p>假设「你」扮演 Bob 的角色，你想知道和你对话的 Alice 是否真的是「可靠的」。 于是把你放入「理想世界」，借助一个具有超能力的 NPC，你可以把对面的 Alice 的知识「抽取」出来。</p>
<p>W…hat？我们不是刚刚证明过：协议是零知识的吗？零知识就意味着 Bob 抽取不出任何的「知识」碎片。这里敲黑板，「零知识」是对于「现实世界」而言的。我们现在正在讨论的是神奇的「理想世界」。</p>
<p>重复一遍，在「理想世界」中，你可以借助一个有超能力的 NPC 来抽取 Alice 的知识，从而可以保证「现实世界」中的 Alice 无法作弊。可以想象一下，一个作弊的 Alice，她肯定没有知识，没有知识也就不可能在「理想世界」中让 NPC 抽取到任何东西。</p>
<p>然而在「现实世界」中，你无法借助 NPC，当然也就看不到 Alice 的知识，也就不会和「零知识」性质冲突。因为两个世界发生的事件是「不可区分」的，我们可以得到这样的结论：在「现实世界」中，Alice 一定是存在知识的。</p>
<p>整理一下思路：如何证明在一个交互会话中 Alice 不能作弊呢？我们需要为这个交互会话定义一个「模拟算法」，该算法可以模拟出一个「理想世界」，其中有一个特殊的角色叫做「抽取器」(Extractor)，也就是我们前面说的 NPC，它能够通过「超能力」来「抽取」Alice 的知识，但是让对方「无所察觉」。</p>
<p>注意，超能力是必不可少的！这一点在『<a href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-intro/2/zkp-simu.md">系列（二）理解「模拟」</a>』有解释，如果模拟器在没有超能力的情况下具备作弊能力，那相当于证明了协议「不可靠」（Unsoudness）。同样地，如果「抽取器」在没有超能力的情况下具备抽取信息能力，那相当于证明了协议不零知（Not-zero-knowledge）。</p>
<p>最后一点，超能力是什么？这个要取决于具体的交互系统的证明，我们接下来就先拿我们刚刚讲过的Schnorr 协议切入。</p>
<h2 id="proof-of-knowledge-知识证明"><a class="header" href="#proof-of-knowledge-知识证明">Proof of Knowledge ：「知识证明」</a></h2>
<p>我们来证明一下 Schnorr 协议的「可靠性」，看看这个超能力 NPC 如何在「理想世界」中把 Alice 私钥抽取出来。而这个「超能力」，仍然是「时间倒流」。</p>
<p><img src="img/schnorr-extractor-1.png" alt="schnorr-extractor-1" /></p>
<p>第一步：Alice 选择一个随机数 <code>r</code>，并且计算 <code>R=r*G</code>，并将 <code>R</code> 发给「抽取器」</p>
<p><img src="img/schnorr-extractor-2.png" alt="schnorr-extractor-2" /></p>
<p>第二步：抽取器也选择一个随机的挑战数<code>c</code>，并且发给 Alice</p>
<p><img src="img/schnorr-extractor-3.png" alt="schnorr-extractor-3" /></p>
<p>第三步：Alice 计算并且回应 <code>z</code>，然后抽取器检查 <code>z</code>是否正确</p>
<p><img src="img/schnorr-extractor-4.png" alt="schnorr-extractor-4" /></p>
<p>第四步：抽取器发现  <code>z</code> 没有问题之后，发动超能力，将时间倒回第二步之前</p>
<p><img src="img/schnorr-extractor-5.png" alt="schnorr-extractor-5" /></p>
<p>第五步：抽取器再次发送一个不同的随机挑战数 <code>c'</code>给 Alice，这时候 Alice 回到第二步，会有一种似曾相识的感觉，但是无法感知到时间倒回这个事实</p>
<p><img src="img/schnorr-extractor-6.png" alt="schnorr-extractor-6" /></p>
<p>第六步：Alice 再次计算了 <code>z'</code>，然后发给抽取器检查</p>
<p><img src="img/schnorr-extractor-7.png" alt="schnorr-extractor-7" /></p>
<p>第七步：这时候抽取器有了<code>z</code>和<code>z'</code>，就可以直接推算出 Alice 所拥有的私钥 <code>a</code>，达成「知识抽取」</p>
<p>到这里，「可靠性」就基本证明完了。大家是不是对可靠性和零知性的「对称性」有点感觉了？</p>
<p>总结一下：「抽取器」在「理想世界」中，通过时间倒流的超能力，把 Alice 的「知识」完整地「抽取」出来，这就保证了一个没有知识的 Alice 是无法让抽取器达成目标，从而证明了「可靠性」。</p>
<p>注：并不是所有的可靠性都必须要求存在抽取器算法。采用抽取器来证明可靠性的证明系统被称为「Proof of Knowledge」。</p>
<h2 id="解读-ecdsa-签名攻击"><a class="header" href="#解读-ecdsa-签名攻击">解读 ECDSA 签名攻击</a></h2>
<p>在区块链系统中到处可见的ECDSA 签名方案<strong>也是</strong>一个朴素的零知识证明系统。椭圆曲线数字签名方案 ECDSA 与 Schnorr 协议非常接近，基于 Schnorr 协议的签名方案发表在 1991年的『密码学杂志』[5]上。1991年，正值美国国家标准局（NIST）选择数字签名算法，优雅的 Schnorr 签名方案居然被申请了专利，因此 NIST 提出了另一套签名方案 DSA（Digital Signature Algorithm），随后这个方案支持了椭圆曲线，于是被称为 ECDSA。中本聪在构思比特币时，选择了 ECDSA 作为签名算法，但是曲线并没有选择 NIST 标准推荐的椭圆曲线 —— secp256-r1，而是 secp256-k1。因为江湖传言，NIST 可能在椭圆曲线参数选择上做了手脚，导致某些机构可以用不为人知的办法求解离散对数难题，从而有能力在「现实世界」中具备超能力。有不少人在怀疑，也许当年中本聪在设计比特币时，也有这种考虑，故意选择了 secp256-k1 这样一条貌似安全性稍弱的曲线。</p>
<p>我们拆解下 ECDSA 签名，用交互的方式定义一个类似 ECDSA 的认证方案，交互见下图。</p>
<p><img src="img/ecdsa.png" alt="ecdsa-sig" /></p>
<p>第一步：Alice 仍然是选择一个随机数 <code>k</code>，并将 <code>k</code> 映射到椭圆曲线上，得到点 <code>K</code> ，然后发送给 Bob</p>
<p>第二步：Bob 需要产生两个随机数，<code>c</code> 和 <code>e</code>，然后交给 Alice</p>
<p>第三步：Alice 计算 <code>s</code>，并且发送给 Bob，他来验证 <code>s</code> 的计算过程是否正确</p>
<p>注：对熟悉 ECDSA 签名方案的读者，这里略作解释，Bob 产生的 <code>c</code> 对应被签消息的 Hash 值 <code>Hash(m)</code>，而 <code>e</code> 则是由一个转换函数 <code>F(K)</code>来产生。其中 <code>F(.)</code> 是取椭圆曲线上的点的 x 坐标经过 <code>(mod q)</code> 得到[6]。</p>
<p>江湖上流传着一个说法：ECDSA 签名方案有个严重的安全隐患，如果在两次签名中使用了同一个随机数，那么签名者的私钥将会暴露出来。其实 Schnorr 签名方案也有同样的问题。</p>
<p>当年 Sony  PlayStation 3 的工程师在调用 ECDSA 库函数时，本来应该输入随机数的参数位置上，却传入了一个常数。熟悉密码学的黑客们发现了这个严重的后门。2011年1月，神奇小子 Geohot 公开发布了 Sony PS3 的主私钥，这意味着任何用户都可以轻松拿到游戏机的 root 权限。Sony 随后大为光火…… （后续故事大家可以上网搜）</p>
<p>如果 Alice 在两次交互过程中使用了同一个 <code>K</code>，那么 Bob 可以通过发送两个不同的 <code>c</code> 和 <code>c'</code> 来得到 <code>s</code> 和 <code>s'</code>，然后通过下面的公式算出私钥 <code>a</code>：</p>
<pre><code>k = (c - c')/(s - s')
a = (k * s - c)/e
</code></pre>
<p>那么我们应该怎么来看这个「安全后门」呢？大家想想看，这个安全后门和我们前面证明过的 Schnorr 协议的可靠性证明几乎一模一样！这个算法正是 ECDSA 认证协议的「可靠性」证明中的「抽取器」算法。只不过在可靠性证明中，为了让 Alice 使用同一个随机数 <code>k</code> 来认证两次，「抽取器」需要利用「时间倒流」的超能力。</p>
<p>但是在 Sony PS3 系统中，随机数被不明所以的工程师写成了一个固定不变的值，这样相当于直接赋予了黑客「超能力」，而这是在「现实世界」中。或者说，黑客在不需要「时间倒流」的情况下就能实现「抽取器」。</p>
<p>提醒下，不仅仅是随机数不能重复的问题。而是随机数必须是具有密码学安全强度的随机数。</p>
<p>设想下，如果随机数 <code>r</code> 是通过一个利用「线性同余」原理的伪随机数生成器产生，虽然 <code>r</code>的值一直在变化，但是仍然不能阻止「知识抽取」。假设线性同余算法为 <code>r2= d*r1 + e (mod m)</code>，还回到 Schnorr 协议的第三步：</p>
<pre><code>1: z1 = r1 + c1*a
2: z2 = r2 + c2*a
</code></pre>
<p>如果攻击者让 Alice 连续做两次签名，那么将 <code>r2</code> 代入  <code>r1</code> 之后，就出现了两个线性方程求解两个未知数 <code>(r1, a)</code> 的情况，<code>z1, z2, c1, c2, d, e</code> 对于 攻击者是已知的，这个方程组只用初中数学知识就可以求解。</p>
<p>请注意，这并不是 Schnorr 协议（或 ECDSA 协议）的「设计缺陷」，恰恰相反，这是 Schnorr 协议设计比较精巧的地方，它<strong>从原理上保证了协议的可靠性</strong>。类似技巧在密码学协议中频繁出现，达到一目了然的「简洁」。但是也不得不说，如果不清楚协议的内在机制，尤其是区分不清楚「理想世界」与「现实世界」，使用者很容易引入各种花式的「安全漏洞」。</p>
<p>作为一个能写出可靠软件的靠谱码农，我们需要了解哪些？彻底理解安全协议的设计机制当然是最好的，但是绝大多数情况下是非常耗费精力的。一般来说，我们把各种密码学工具当做「黑盒」来用，可能是不够的，我们最好还能了解下：</p>
<ol>
<li>「安全定义」是什么？</li>
<li>「安全假设」到底是什么？</li>
<li>「理想世界」中的「超能力」到底是什么？</li>
</ol>
<h2 id="脑洞我们生活在模拟世界中吗"><a class="header" href="#脑洞我们生活在模拟世界中吗">脑洞：我们生活在模拟世界中吗</a></h2>
<p>第一次读懂「模拟器」时，我第一时间想到的是电影『黑客帝国』。我们生活所在「现实世界」也许是某一个模拟器模拟出来的「理想世界」，我们所看到、听到的以及感知到的一切都是被「模拟」出来的。在「现实世界」里，我们活在一个母体中。然而我们并不能意识到这一点。</p>
<p><img src="img/matrix.jpg" alt="" /></p>
<p>早在春秋战国时期，庄子也在思考类似的问题：</p>
<blockquote>
<p>昔者庄周梦为胡蝶，栩栩然胡蝶也，自喻适志与，不知周也。俄然觉，则蘧蘧然周也。不知周之梦为胡蝶与，胡蝶之梦为周与？周与胡蝶，则必有分矣。此之谓物化。——《庄子·齐物论》</p>
</blockquote>
<p>通俗地解释下：庄子有一天睡着了，梦见自己变成了一只蝴蝶，翩翩起舞，醒来之后发现自己还是庄子，在梦中，蝴蝶并不知道自己是庄子。于是庄子沉思到底是他梦中变成了蝴蝶，还是蝴蝶梦中变成了庄子呢？如果梦境足够真实，……</p>
<p>「缸中之脑」是美国哲学家 Gilbert Harman 提出的这样一个想法：一个人的大脑可以被放入一个容器里面，然后插上电线，通过模拟各种电信号输入，使得大脑以为自己活在真实世界中。</p>
<p><img src="img/brain-in-a-vat.png" alt="" /></p>
<p>这个想法源自哲学家笛卡尔的《第一哲学沉思集》[7]，在书中他论证我们应该怀疑一切，需要逐一检验所有人类的知识，数学，几何，以及感知到的世界。然而他发现除了「我思故我在」之外，所有的知识都可能不靠谱，因为我们的大脑很可能被一个具有「超能力」的 Evil Demon 所欺骗。</p>
<p>2003 年牛津大学的哲学教授 Nick Bostrom 郑重其事地写了一篇论文『我们生活在计算机模拟世界中吗？』[8]。认为以下三个事实中，至少有一个成立：</p>
<ol>
<li>人类文明彻底灭绝。</li>
<li>人类文明已经到达可以完全模拟现实世界的科技水平，但是处于某种原因，没有一个人愿意去创造出一个新的模拟世界，充当上帝的角色。</li>
<li>我们现在的人类文明就生活在一个模拟世界中。</li>
</ol>
<p>硅谷企业家 Elon Musk 在一次公开采访中，谈到「我们生活在基础现实世界」的概率只有「十亿分之一」。也就是说，他认为我们生活在一个电脑游戏（模拟世界）中，在模拟世界之外，有一个程序员，他开发并操纵了这个世界，我们每个人都是一个游戏角色（ NPC）。</p>
<p>在玩腻越狱 iPhone 和自动驾驶之后，神奇小子 Geohot 在今年三月份的「西南偏南」大会上做了一个题为「Jailbreaking the Simulation」的演讲[9]。他认为，我们被生活在一个模拟世界中，所谓的上帝就是外部世界里活蹦乱跳的码农们，他们编程创造了我们的「现实世界」，当然，他们可能启动了不止一个世界副本。然而，他们可能也生活在一个外层「模拟世界」中。</p>
<p><img src="img/sxsw.jpg" alt="Jailbreaking the Simulation" /></p>
<p>如果我们确实生活在模拟世界中，或许我们可以在地球的某个地方找到一个后门——「Simulation Trapdoor」，从而获得「模拟器」的超能力，抽取出不可思议的「秘密知识」。</p>
<p>如果我们的世界的确是被程序模拟出来的，这个程序也许会有 Bug，如果有 Bug 存在，说不定我们可以利用这个 Bug 进行越狱，跳出「理想世界」，到达外面一层的世界中，与可爱的码农上帝聊一聊。</p>
<p>这是在开玩笑吗？下面摘自自知乎的一个段子[10]：</p>
<ul>
<li>问题：「如果世界是虚拟的，有哪些实例可以证明？」。</li>
<li>回答：</li>
</ul>
<blockquote>
<ol>
<li>为什么宏观上丰富多彩，但是微观的基本粒子却都是一模一样的？这正和图片富多彩，但是像素是一模一样的一回事</li>
<li>为什么光速有上限？因为机器的运行速度有限</li>
<li>为什么会有普朗克常量？因为机器的数据精度有限</li>
<li>为什么微观粒子都是几率云？这是为了避免系统陷入循环而增加的随机扰动</li>
<li>为什么有泡利不相容原理？看来系统采用的数据组织是多维数组</li>
<li>为什么量子计算机运行速度那么快，一瞬间可以尝试所有可能？因为这个本质上是调用了宿主机的接口</li>
<li>为什么会有量子纠缠？这实际上是引用同一个对象的两个指针</li>
<li>为什么会有观察者效应？这显然是lazy updating</li>
<li>为什么时间有开端？系统有启动时间</li>
</ol>
</blockquote>
<h2 id="未完待续"><a class="header" href="#未完待续">未完待续</a></h2>
<p>设计一个密码学协议就好像在走钢丝，如果你想同时做到「零知识」和「可靠性」就意味着既要让协议内容充分随机，又要保证「知识」能够参与协议的交互。如果协议没有正确设计，亦或没有正确工程实现，都将导致系统安全性坍塌。比如可能破坏了零知性，导致「知识」在不经意间泄露；或者也许破坏了可靠性，导致任何人都能伪造证明。而且这种安全性，远比传统的代码底层机制漏洞来得更加严重，并且更难被发现。严格数学论证，这似乎是必不可少的。</p>
<p>我们的世界真的是某个「三体文明」模拟出来的吗？不能排除这个可能性，或许，我们需要认真地重新审视自己的各种执念。不过那又怎么样呢？至少自己的「思想」是真实的。</p>
<blockquote>
<p>If you would be a real seeker after truth, it is necessary that at least once in your life you doubt, as far as possible, all things.  如果你是一个真正的真理探求者，在你人生中至少要有一次，尽可能地质疑所有的事情。
—— 笛卡尔</p>
</blockquote>
<p><em>致谢：特别感谢 Shengchao Ding, Jie Zhang，Yu Chen 以及安比实验室小伙伴们(p0n1, even, aphasiayc, Vawheter, yghu, mr)的建议和指正。</em></p>
<h3 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h3>
<ul>
<li>[1] zkPoD: 区块链，零知识证明与形式化验证，实现无中介、零信任的公平交易. 安比实验室. 2019.</li>
<li>[2] Hoffstein, Jeffrey, Jill Pipher, Joseph H. Silverman, and Joseph H. Silverman. An introduction to mathematical cryptography. Vol. 1. New York: springer, 2008.</li>
<li>[3] Schwartz–Zippel Lemma. Wikipedia.  https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma</li>
<li>[4] Damgård, Ivan. “On Σ-protocols.” <em>Lecture Notes, University of Aarhus, Department for Computer Science</em> (2002).</li>
<li>[5] Schnorr, Claus-Peter. “Efficient signature generation by smart cards.” <em>Journal of cryptology</em> 4.3 (1991): 161-174.</li>
<li>[6] Brown, Daniel RL. “Generic groups, collision resistance, and ECDSA.” <em>Designs, Codes and Cryptography</em> 35.1 (2005): 119-152.</li>
<li>[7] 笛卡儿, 徐陶. 第一哲学沉思集. 九州出版社; 2008.</li>
<li>[8] Bostrom, Nick. “Are we living in a computer simulation?.” The Philosophical Quarterly 53.211 (2003): 243-255.</li>
<li>[9] Nick Statt. “Comma.ai founder George Hotz wants to free humanity from the AI simulation”. Mar 9, 2019. https://www.theverge.com/2019/3/9/18258030/george-hotz-ai-simulation-jailbreaking-reality-sxsw-2019</li>
<li>[10] doing@知乎. “如果世界是虚拟的，有哪些实例可以证明？”. 2017. https://www.zhihu.com/question/34642204/answer/156671701</li>
</ul>
<footer id="open-on-gh">Found a bug?! <a href="https://github.com/zkp-co-learning/zkp-co-learning.github.io/edit/main/src/zkp-intro/3/zkp-pok.md">Edit this page on GitHub.</a></footer>
                        <hr>
                        <div class="giscus"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../zkp-intro/2/zkp-simu.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../zkp-intro/4/zkp-rom.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../zkp-intro/2/zkp-simu.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../zkp-intro/4/zkp-rom.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/mermaid.min.js"></script>
        <script src="../../theme/mermaid-init.js"></script>


    </div>

    <script type="text/javascript">
        var langs = [
            'cn',
            'en',
        ];

        (function initLangs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

            // For each language, update the link to point to the current page in that language
            let linkParts = window.location.pathname.split('/');
            let langIndex = linkParts.findIndex((s) => langs.includes(s));
            langs.forEach(function (lang) {
                var link = document.getElementById('lang-' + lang);
                if (!link) {
                    return;
                }

                let newLinkParts = linkParts.slice();

                // If it is Chinese, remove the current language from the path
                if (lang === "cn") {
                    if (langIndex !== -1) {
                        newLinkParts.splice(langIndex, 1);
                    }
                }
                
                // Otherwise, add the new language to the path
                else {
                    if (langIndex === -1) {
                        // Modify this line to insert the language right after the domain
                        newLinkParts.splice(1, 0, lang);
                    } else {
                        newLinkParts[langIndex] = lang;
                    }
                }

                link.href = newLinkParts.join('/');
            });
        })();

        </script>
        <script src="https://giscus.app/client.js"
                data-repo="zkp-co-learning/zkp-co-learning.github.io"
                data-repo-id="R_kgDOKNpxMQ"
                data-category="Announcements"
                data-category-id="DIC_kwDOKNpxMc4CZ2LA"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="light"
                data-lang="zh-CN"
                crossorigin="anonymous"
                async>
        </script>
    </body>
</html>
